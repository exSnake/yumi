{"comment": "///\\n/// FuturedWidget is a wrapper for the [FutureBuilder] widget. It provides\\n/// some callbacks to handle the state of the future and returning a\\n/// [Container] if `onWaitingChild` is not provided, in order to avoid\\n/// checking `snapshot.hasData`.\\n///\\n///\\n/// #### Usage\\n///\\n/// ```dart\\n/// FuturedWidget<String>(\\n///   future: future,\\n///   builder: (BuildContext context, snasphot) => Text(snasphot.data),\\n///   initialData: // Data to provide if the snapshot is null or still not completed\\n///   waitingChild: // Widget to show on waiting\\n///   onWaiting: () => // or Callback\\n///   errorChild: // Widget to show on error\\n///   onError: (error) => // or Callback\\n/// )\\n/// ```\\n///\\n/// If no [onWaitingChild] widget or [onWaiting] callback is provided then\\n/// a [Container] is returned.\\n///\\n/// If no [errorChild] widget or no [onError] callback is provided then\\n/// a [Container] is returned.\\n///\\n/// N.B. The callbacks are executed only if their respective child is\\n/// not provided.\\n///\\n///\\n", "code": "class FuturedWidget<T> extends StatelessWidget {\\n  const FuturedWidget(\\n      {@required this.future,\\n      @required this.builder,\\n      Key key,\\n      this.initialData,\\n      this.onWaitingChild,\\n      this.onWaiting,\\n      this.errorChild,\\n      this.onError})\\n      : assert(future != null, 'The future argument is null.'),\\n        assert(builder != null, 'The builder argument is null.'),\\n        super(key: key);\\n\\n  final T initialData;\\n  final Future<T> future;\\n  final AsyncWidgetBuilder<T> builder;\\n\\n  ///\\n  /// If the snapshot has no data then this widget is returned\\n  final Widget onWaitingChild;\\n\\n  ///\\n  /// If no [onWaitingChild] is provided then the [onWaiting] callback is called\\n  final WaitingCallback onWaiting;\\n\\n  ///\\n  /// This widget is returned if there is an error\\n  final Widget errorChild;\\n\\n  ///\\n  /// If no [errorChild] is provided then the [onError] callback is called\\n  final ErrorCallback onError;\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return FutureBuilder<T>(\\n        initialData: initialData,\\n        future: future,\\n        builder: (context, snapshot) {\\n          if (snapshot.hasData) {\\n            return builder(context, snapshot);\\n          }\\n\\n          if (snapshot.hasError) {\\n            if (errorChild != null) {\\n              return errorChild;\\n            } else {\\n              return onError != null ? onError(snapshot.error) : Container();\\n            }\\n          }\\n\\n          if (onWaitingChild != null) {\\n            return onWaitingChild;\\n          } else {\\n            return onWaiting != null ? onWaiting() : Container();\\n          }\\n        });\\n  }\\n}\\n", "commentSize": 1032, "codeSize": 1684, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Used with a [Stream] when the type is a widget to\\n/// directly stream a widget to the view. Under the hood\\n/// a [StreamedWidget] handles the stream and shows\\n/// the widget.\\n///\\n///\\n", "code": "class ReceiverWidget extends StatelessWidget {\\n  const ReceiverWidget({Key key, this.stream})\\n      : assert(stream != null, 'The strean argument is null.'),\\n        super(key: key);\\n\\n  final Stream<Widget> stream;\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return StreamedWidget<Widget>(\\n        stream: stream, builder: (context, snapshot) => snapshot.data);\\n  }\\n}\\n", "commentSize": 198, "codeSize": 393, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// This widget uses a [ScenesObject] for the timing of the widgets\\n/// visualization.\\n///\\n/// It takes as a parameter a List<Scene> and plays every [Scene].\\n///\\n/// By default to change the stage is used the relative time, so the time\\n/// parameter of the [Scene] indicates how much time the stage will lasts.\\n/// Instead, to specify the absolute time, set to true the [absoluteTiming]\\n/// flag, in this case the time parameter indicates the absolute time when\\n/// to show the scene.\\n///\\n/// The [onStart] is used to call a function when the ScenesObject begins\\n/// to play the stages.\\n///\\n/// The [onEnd] callback is called at the end of the last stage when the timeing\\n/// is relative (the [absoluteTiming] flag is set to false).\\n///\\n/// #### Usage\\n/// From the ScenesObject example:\\n///\\n/// ```dart\\n///ScenesCreate(\\n///  scenes: [\\n///    Scene(\\n///         widget: SingleScene(\\n///          color: Colors.white,\\n///          text: 'Scene 1',\\n///        ),\\n///        time: 3500,\\n///        onShow: () {\\n///          print('Showing scene 1');\\n///        }),\\n///    Scene(\\n///        widget: SingleScene(\\n///          color: Colors.blue,\\n///          text: 'Scene 2',\\n///        ),\\n///        time: 3500,\\n///        onShow: () {\\n///          print('Showing scene 2');\\n///        }),\\n///    Scene(\\n///        widget: SingleScene(\\n///          color: Colors.brown,\\n///          text: 'Scene 3',\\n///        ),\\n///        time: 3500,\\n///        onShow: () {\\n///          print('Showing scene 3');\\n///        }),\\n///  ],\\n///  onStart: () => print('Start playing scenes!'),\\n///  onEnd: () => print('End playing scenes!'),\\n///),\\n///\\n///\\n///// The singleScene widget:\\n///\\n/// class SingleScene extends StatelessWidget {\\n///   const SingleScene({Key key, this.text, this.color}) : super(key: key);\\n///\\n///   final String text;\\n///   final Color color;\\n///\\n///   @override\\n///   Widget build(BuildContext context) {\\n///     return Container(\\n///       alignment: Alignment.center,\\n///       color: color,\\n///       child: Text(text),\\n///     );\\n///   }\\n/// }\\n/// ```\\n", "code": "class ScenesCreate extends StatefulWidget {\\n  const ScenesCreate(\\n      {@required this.scenes,\\n      Key key,\\n      this.absoluteTiming = false,\\n      this.onStart,\\n      this.onEnd})\\n      : assert(scenes != null, 'The scenes argument is null.'),\\n        super(key: key);\\n\\n  final List<Scene> scenes;\\n  final bool absoluteTiming;\\n  final Function onStart;\\n  final Function onEnd;\\n\\n  @override\\n  _ScenesCreateState createState() {\\n    return _ScenesCreateState();\\n  }\\n}\\n", "commentSize": 2143, "codeSize": 491, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// A simple widget that animates a input string making a scrolling text\\n/// over a given time.\\n///\\n", "code": "class ScrollingText extends StatefulWidget {\\n  const ScrollingText(\\n      {@required this.text,\\n      @required this.scrollingDuration,\\n      Key key,\\n      this.style})\\n      : assert(text != null, 'The text argument is null.'),\\n        assert(\\n            scrollingDuration != null, 'The scrollDuration argument is null.'),\\n        super(key: key);\\n\\n  final String text;\\n  final int scrollingDuration;\\n  final TextStyle style;\\n\\n  @override\\n  _ScrollingTextState createState() {\\n    return _ScrollingTextState();\\n  }\\n}\\n", "commentSize": 108, "codeSize": 540, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// This widget uses a [StagedObject] for the timing of the widgets\\n/// visualization.\\n///\\n/// It takes as a parameter a Map<int, Stage> and plays every [Stage].\\n///\\n/// By default to change the stage is used the relative time, so the time\\n/// parameter of the [Stage] indicates how much time the stage will lasts.\\n/// Instead, to specify the absolute time, set to true the [absoluteTiming]\\n/// flag, in this case the time parameter indicates the absolute time when\\n/// to show the widget.\\n///\\n/// The [onStart] is used to call a function when the StagesObject begins\\n/// to play the stages.\\n///\\n/// The [onEnd] callback is called at the end of the last stage when the timeing\\n/// is relative (the [absoluteTiming] flag is set to false).\\n///\\n///\\n", "code": "class StagedWidget extends StatefulWidget {\\n  const StagedWidget(\\n      {@required this.stagesMap,\\n      Key key,\\n      this.absoluteTiming = false,\\n      this.onStart,\\n      this.onEnd})\\n      : assert(stagesMap != null, 'The stagesMap argument is null.'),\\n        super(key: key);\\n\\n  final Map<int, Stage> stagesMap;\\n  final bool absoluteTiming;\\n  final Function onStart;\\n  final Function onEnd;\\n\\n  @override\\n  _StagedWidgetState createState() {\\n    return _StagedWidgetState();\\n  }\\n}\\n", "commentSize": 774, "codeSize": 507, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// AnimationBaseClass\\n///\\n///\\n///\\n///\\n", "code": "class AnimationBaseClass {\\n  AnimationBaseClass({\\n    this.duration,\\n    this.setState,\\n    this.tickerProvider,\\n    this.onAnimating,\\n  });\\n\\n  final Duration duration;\\n  final dynamic setState;\\n  final TickerProvider tickerProvider;\\n  final AnimationStatusCallback onAnimating;\\n\\n  // Controller and getters\\n  AnimationController baseController;\\n  AnimationStatus get status => baseController.status;\\n\\n  bool get isAnimating => baseController.isAnimating;\\n  bool get isCompleted => baseController.isCompleted;\\n  bool get isDismissed => baseController.isDismissed;\\n\\n  double get controllerValue => baseController.value;\\n  double get progress => controllerValue * 100.0;\\n\\n  void init() {\\n    baseController = AnimationController(\\n      duration: duration,\\n      vsync: tickerProvider,\\n    );\\n\\n    if (onAnimating != null) {\\n      baseController.addListener(() {\\n        setState(() {});\\n        onAnimating(status);\\n      });\\n    } else {\\n      baseController.addListener(() {\\n        setState(() {});\\n      });\\n    }\\n  }\\n\\n  void forward() {\\n    baseController.forward();\\n  }\\n\\n  void reverse() {\\n    baseController.reverse();\\n  }\\n\\n  void dispose() {\\n    baseController.dispose();\\n  }\\n\\n  void stop({bool canceled}) {\\n    baseController.stop(canceled: canceled);\\n  }\\n", "commentSize": 49, "codeSize": 1320, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// AnimationTween\\n///\\n///\\n///\\n///\\n", "code": "class AnimationTween<T> extends AnimationBaseClass {\\n  AnimationTween({\\n    @required this.begin,\\n    @required this.end,\\n    dynamic setState,\\n    TickerProvider tickerProvider,\\n    Duration duration,\\n    this.controller,\\n    AnimationStatusCallback onAnimating,\\n  })  : assert(begin != null && end != null),\\n        super(\\n          duration: duration,\\n          setState: setState,\\n          tickerProvider: tickerProvider,\\n          onAnimating: onAnimating,\\n        ) {\\n    // If a controller is not provided, then is\\n    // called the `init` method of the AnimationBaseClass to initialize\\n    // its `baseController`\\n    if (controller == null) {\\n      super.init();\\n    }\\n\\n    animation =\\n        Tween<T>(begin: begin, end: end).animate(controller ?? baseController);\\n  }\\n\\n  final T begin;\\n  final T end;\\n\\n  final AnimationController controller;\\n  Animation<T> animation;\\n\\n  T get value => animation.value;\\n}\\n", "commentSize": 45, "codeSize": 952, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// AnimationCurved\\n///\\n///\\n///\\n///\\n", "code": "class AnimationCurved<T> extends AnimationBaseClass {\\n  AnimationCurved({\\n    this.controller,\\n    @required this.begin,\\n    @required this.end,\\n    @required this.curve,\\n    this.reverseCurve,\\n    dynamic setState,\\n    TickerProvider tickerProvider,\\n    Duration duration,\\n    AnimationStatusCallback onAnimating,\\n  })  : assert(begin != null && end != null && curve != null),\\n        super(\\n          duration: duration,\\n          setState: setState,\\n          tickerProvider: tickerProvider,\\n          onAnimating: onAnimating,\\n        ) {\\n    // If a controller is not provided, then is\\n    // called the `init` method of the AnimationBaseClass to initialize\\n    // its `baseController`\\n    if (controller == null) {\\n      super.init();\\n    }\\n    animation = Tween<T>(begin: begin, end: end).animate(CurvedAnimation(\\n        parent: controller ?? baseController,\\n        curve: curve,\\n        reverseCurve: reverseCurve));\\n  }\\n\\n  final T begin;\\n  final T end;\\n\\n  final Curve curve;\\n  final Curve reverseCurve;\\n\\n  final AnimationController controller;\\n  Animation<T> animation;\\n\\n  T get value => animation.value;\\n}\\n", "commentSize": 46, "codeSize": 1159, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// AnimationCreate\\n///\\n///\\n///\\n///\\n", "code": "class AnimationCreate<T> extends StatefulWidget {\\n  const AnimationCreate({\\n    Key key,\\n    @required this.begin,\\n    @required this.end,\\n    this.curve = Curves.linear,\\n    this.reverseCurve = Curves.linear,\\n    this.duration = 1000,\\n    this.repeat = false,\\n    this.reverse = false,\\n    this.onAnimating,\\n    this.onStart,\\n    this.onCompleted,\\n    this.builder,\\n  }) : super(key: key);\\n\\n  final T begin;\\n  final T end;\\n  final Curve curve;\\n  final Curve reverseCurve;\\n  final int duration;\\n  final Function onAnimating;\\n  final Function onCompleted;\\n  final Function onStart;\\n  final AnimationCreateBuilder builder;\\n  final bool repeat;\\n  final bool reverse;\\n\\n  @override\\n  _AnimationCreateState<T> createState() => _AnimationCreateState<T>();\\n}\\n", "commentSize": 46, "codeSize": 782, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// CompositeItem\\n///\\n///\\n///\\n///\\n", "code": "class CompositeItem<T> {\\n  CompositeItem({\\n    @required this.begin,\\n    @required this.end,\\n    this.curve,\\n    this.reverseCurve,\\n  }) : assert(begin != null && end != null);\\n\\n  final T begin;\\n  final T end;\\n\\n  final Curve curve;\\n  final Curve reverseCurve;\\n\\n  Animation<dynamic> animation;\\n}\\n", "commentSize": 44, "codeSize": 311, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// CompositeAnimation\\n///\\n///\\n///\\n///\\n", "code": "class CompositeAnimation extends AnimationBaseClass {\\n  CompositeAnimation({\\n    @required this.composite,\\n    @required dynamic setState,\\n    @required TickerProvider tickerProvider,\\n    @required Duration duration,\\n    AnimationStatusCallback onAnimating,\\n  })  : assert(\\n          composite != null &&\\n              composite.isNotEmpty &&\\n              setState != null &&\\n              tickerProvider != null &&\\n              duration != null,\\n        ),\\n        super(\\n          duration: duration,\\n          setState: setState,\\n          tickerProvider: tickerProvider,\\n          onAnimating: onAnimating,\\n        ) {\\n    // Init the AnimationBaseClass\\n    super.init();\\n\\n    composite.values.forEach((tween) {\\n      if (tween.curve == null) {\\n        if (tween.begin.runtimeType == MaterialColor) {\\n          tween.animation = ColorTween(begin: tween.begin, end: tween.end)\\n              .animate(baseController);\\n        } else {\\n          tween.animation = Tween<dynamic>(begin: tween.begin, end: tween.end)\\n              .animate(baseController);\\n        }\\n      } else {\\n        if (tween.begin.runtimeType == MaterialColor) {\\n          tween.animation = ColorTween(begin: tween.begin, end: tween.end)\\n              .animate(baseController);\\n        } else {\\n          tween.animation = Tween<dynamic>(begin: tween.begin, end: tween.end)\\n              .animate(CurvedAnimation(\\n                  parent: baseController,\\n                  curve: tween.curve,\\n                  reverseCurve: tween.reverseCurve));\\n        }\\n      }\\n    });\\n  }\\n\\n  final Map<dynamic, CompositeItem<dynamic>> composite;\\n\\n  dynamic value(dynamic key) => composite[key].animation.value;\\n\\n  int valueInt(dynamic key) => composite[key].animation.value.toInt();\\n\\n  dynamic animation(dynamic key) => composite[key].animation;\\n\\n  AnimationStatus animationStatus(dynamic key) =>\\n      composite[key].animation.status;\\n}\\n", "commentSize": 49, "codeSize": 1961, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// CompositeCreate\\n///\\n///\\n///\\n///\\n", "code": "class CompositeCreate extends StatefulWidget {\\n  const CompositeCreate({\\n    Key key,\\n    this.duration = 1000,\\n    this.compositeMap,\\n    this.repeat = false,\\n    this.onAnimating,\\n    this.onStart,\\n    this.onCompleted,\\n    this.builder,\\n  }) : super(key: key);\\n\\n  final int duration;\\n  final Map<dynamic, CompositeItem> compositeMap;\\n  final Function onAnimating;\\n  final Function onCompleted;\\n  final Function onStart;\\n  final CompositeCreateBuilder builder;\\n  final bool repeat;\\n\\n  @override\\n  _CompositeCreateState createState() => _CompositeCreateState();\\n}\\n", "commentSize": 46, "codeSize": 588, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Enum to handle the status of the animation.\\n///\\n", "code": "enum AnimatedStatus { active, stop, pause }\\n", "commentSize": 59, "codeSize": 45, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Enum to specify the behavior of the animation for\\n/// the `startAnimation` method.\\n///\\n", "code": "enum AnimatedType { increment, decrement }\\n", "commentSize": 99, "codeSize": 44, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// This class is used to update a value over a period of time.\\n/// Useful to handle animations using the BLoC pattern.\\n///\\n/// From the AnimatedObject example:\\n///\\n/// #### Usage\\n///\\n/// #### In the BLoC:\\n///\\n///  ```dart\\n///  //Initial value 0.5, updating interval 20 milliseconds\\n///  final scaleAnimation =\\n///      AnimatedObject<double>(initialValue: 0.5, interval: 20);\\n///\\n///  start() {\\n///    scaleAnimation.start(updateScale);\\n///  }\\n///\\n///  updateScale(Timer t) {\\n///    scaleAnimation.animation.value += 0.02;\\n///\\n///    if (scaleAnimation.animation.value > 5.0) {\\n///      scaleAnimation.reset();\\n///    }\\n///  }\\n///\\n///  stop() {\\n///    scaleAnimation.stop();\\n/// }\\n///\\n///  reset() {\\n///   scaleAnimation.reset();\\n///  }\\n///```\\n///\\n///- #### In the view:\\n///\\n///```dart\\n///      Container(\\n///          color: Colors.blueGrey[100],\\n///          child: Column(\\n///            children: <Widget>[\\n///              Container(height: 20.0,),\\n///              ValueBuilder<AnimatedStatus>(\\n///                streamed: bloc.scaleAnimation.status,\\n///                builder: (context, snapshot) {\\n///                 return Row(\\n///                    mainAxisAlignment: MainAxisAlignment.center,\\n///                    children: <Widget>[\\n///                      snapshot.data == AnimatedStatus.active\\n///                          ? RaisedButton(\\n///                              color: Colors.lightBlueAccent,\\n///                              child: Text('Reset'),\\n///                              onPressed: () {\\n///                                bloc.reset();\\n///                              })\\n///                          : Container(),\\n///                      snapshot.data == AnimatedStatus.stop\\n///                         ? RaisedButton(\\n///                              color: Colors.lightBlueAccent,\\n///                              child: Text('Start'),\\n///                              onPressed: () {\\n///                                bloc.start();\\n///                              })\\n///                          : Container(),\\n///                      snapshot.data == AnimatedStatus.active\\n///                          ? RaisedButton(\\n///                              color: Colors.lightBlueAccent,\\n///                              child: Text('Stop'),\\n///                              onPressed: () {\\n///                                bloc.stop();\\n///                              })\\n///                          : Container(),\\n///                    ],\\n///                  );\\n///                },\\n///              ),\\n///              Expanded(\\n///                child: ValueBuilder<double>(\\n///                    streamed: bloc.scaleAnimation,\\n///                    builder: (context, snapshot) {\\n///                      return Transform.scale(\\n///                          scale: snapshot.data, child: FlutterLogo());\\n///                   }),\\n///              )\\n///            ],\\n///          ),\\n///        ),\\n///```\\n///\\n///\\n", "code": "class AnimatedObject<T> implements StreamedObject<T> {\\n  AnimatedObject({@required this.initialValue, @required this.interval})\\n      : assert(initialValue != null, 'The initialValue argument is null.'),\\n        assert(interval != null, 'The interval argument is null.') {\\n    status.value = AnimatedStatus.stop;\\n  }\\n\\n  /// It is the [StreamedValue] object that holds the animation value\\n  final StreamedValue<T> animation = StreamedValue<T>();\\n\\n  /// Getter for stream of the [StreamedValue] that holds the animation\\n  /// value.\\n  @override\\n  Stream<T> get outStream => animation.outStream;\\n\\n  /// Deprecated. use [outStream] instead, this is used by [ValueBuilder].\\n  ///\\n  /// Getter for stream of the [StreamedValue] that holds the animation\\n  /// value.\\n  @Deprecated('Used the outStream getter instead.')\\n  Stream<T> get animationStream => animation.outStream;\\n\\n  /// Getter for the AnimatedObject value\\n  @override\\n  T get value => animation.value;\\n\\n  /// Setter for the AnimatedObject value\\n  set value(T value) => animation.value = value;\\n\\n  /// The initial value of the animation\\n  T initialValue;\\n\\n  /// Timer to handle the timing\\n  final TimerObject timer = TimerObject();\\n\\n  /// Interval in milliseconds\\n  int interval;\\n\\n  ///\\n  /// AnimatedObject status\\n  ///\\n  final StreamedValue<AnimatedStatus> status = StreamedValue<AnimatedStatus>();\\n\\n  /// Getter for the stream of the status of the animation\\n  Stream<AnimatedStatus> get statusStream => status.outStream;\\n\\n  /// Status getter\\n  AnimatedStatus get getStatus => status.value;\\n\\n  /// Method to check if the animation is playing or not.\\n  bool isAnimating() {\\n    if (getStatus == AnimatedStatus.active) {\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /// In the callback increase the animation.value!\\n  void start(Function(Timer t) callback) {\\n    if (!timer.isTimerActive) {\\n      animation.value = initialValue;\\n      timer.startPeriodic(Duration(milliseconds: interval), callback);\\n      status.value = AnimatedStatus.active;\\n    }\\n  }\\n\\n  ///\\n  /// Method to start animating the value.\\n  ///\\n  /// - `type`: with this parameter specify if the the value\\n  /// has to be incremented or decremented\\n  ///\\n  ///\\n  /// - `velocity`: entity of the increment/decrement\\n  ///\\n  ///\\n  /// - `minValue` and `maxValue`: if an [AnimatedType] of value `increment`\\n  /// is set, then a `maxValue` parameter must be given. If `decrement`, a\\n  /// `minValue` must be set. Once reached a min or a max value, the\\n  /// animation stops.\\n  ///\\n  void startAnimation(\\n      {@required AnimatedType type,\\n      @required dynamic velocity,\\n      dynamic minValue,\\n      dynamic maxValue}) {\\n    assert(type != null && velocity != null,\\n        'type and velocity parameters must be not null.');\\n\\n    dynamic valueTmp = initialValue;\\n\\n    switch (type) {\\n      case AnimatedType.increment:\\n        assert(maxValue != null, 'The parameter maxValue must be not null.');\\n\\n        start((t) {\\n          if (valueTmp < maxValue) {\\n            valueTmp += velocity;\\n            value = valueTmp;\\n          }\\n\\n          if (valueTmp >= maxValue) {\\n            value = maxValue;\\n            stop();\\n          }\\n        });\\n        break;\\n      case AnimatedType.decrement:\\n        assert(minValue != null, 'The parameter maxValue must be not null.');\\n\\n        start((t) {\\n          if (valueTmp > minValue) {\\n            valueTmp -= velocity;\\n            value = valueTmp;\\n          }\\n\\n          if (valueTmp <= minValue) {\\n            value = minValue;\\n            stop();\\n          }\\n        });\\n        break;\\n      default:\\n        break;\\n    }\\n  }\\n\\n  /// Method to stop the animation-\\n  void stop() {\\n    timer.stopTimer();\\n    status.value = AnimatedStatus.stop;\\n  }\\n\\n  /// Method to reset the animation. It doesn't stop the animation, it just\\n  /// sets the animation.value to the [initialValue].\\n  void reset() {\\n    animation.value = initialValue;\\n  }\\n\\n  /// Method to pause the animation\\n  void pause() {\\n    status.value = AnimatedStatus.pause;\\n  }\\n\\n  void dispose() {\\n    animation.dispose();\\n    timer.dispose();\\n  }\\n}\\n", "commentSize": 3072, "codeSize": 4242, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// Used when T is a list, it works like [StreamedValue].\\n///\\n/// To modify the list (e.g. adding items) and update the stream automatically\\n/// use these methods:\\n///\\n/// - [addAll]\\n/// - [addElement]\\n/// - [clear]\\n/// - [removeAt]\\n/// - [removeElement]\\n/// - [replace]\\n/// - [replaceAt]\\n///\\n/// For other direct actions on the list, to update the stream call\\n/// the [refresh] method instead.\\n///\\n/// #### Usage\\n///\\n/// e.g. adding an item:\\n///\\n/// ```dart\\n///   streamedList.addElement(item);\\n/// ```\\n///\\n/// it is the same as:\\n///\\n/// ```dart\\n///   streamedList.value.add(item);\\n///   streamedList.refresh();\\n/// ```\\n///\\n/// From the StreamedList example:\\n///\\n/// ```dart\\n/// final streamedList = StreamedList<String>();\\n///\\n///\\n/// // Add to the streamed list the string from the textfield\\n/// addText() {\\n///   streamedList.addElement(streamedText.value);\\n///\\n///   // Or, as an alternative:\\n///   // streamedList.value.add(streamedText.value);\\n///   // streamedList.refresh(); // To refresh the stream with the new value\\n/// }\\n/// ```\\n///\\n///\\n", "code": "class StreamedList<T> implements StreamedObject<List<T>> {\\n  StreamedList({List<T> initialData, this.onError}) {\\n    stream = StreamedValue<List<T>>()\\n      ..stream.listen((data) {\\n        if (_onChange != null) {\\n          _onChange(data);\\n        }\\n      }, onError: onError);\\n\\n    if (initialData != null) {\\n      stream.value = initialData;\\n    }\\n  }\\n", "commentSize": 1108, "codeSize": 369, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// Used when T is a map, it works like [StreamedValue].\\n///\\n/// To modify the list (e.g. adding items) and update the stream automatically\\n/// use these methods:\\n///\\n/// - [addKey]\\n/// - [clear]\\n/// - [removeKey]\\n///\\n/// For other direct actions on the map, to update the stream call\\n/// the [refresh] method instead.\\n///\\n/// #### Usage\\n///\\n/// e.g. adding a key/value pair:\\n///\\n/// ```dart\\n///   streamedMap.addKey(1, 'first');\\n/// ```\\n///\\n/// it is the same as:\\n///\\n/// ```dart\\n///   streamedMap.value[1] = 'first';\\n///   streamedList.refresh();\\n/// ```\\n///\\n///\\n/// From the streamed map example:\\n///\\n/// ```dart\\n///  final streamedMap = StreamedMap<int, String>();\\n///\\n///\\n///  // Add to the streamed map the key/value pair put by the user\\n///  addText() {\\n///     var key = int.parse(streamedKey.value);\\n///     var value = streamedText.value;\\n///\\n///     streamedMap.addKey(key, value);\\n///\\n///     // Or, as an alternative:\\n///     //streamedMap.value[key] = value;\\n///     //streamedMap.refresh();\\n///   }\\n/// ```\\n///\\n///\\n", "code": "class StreamedMap<K, V> implements StreamedObject<Map<K, V>> {\\n  StreamedMap({Map<K, V> initialData, this.onError}) {\\n    stream = StreamedValue<Map<K, V>>()\\n      ..stream.stream.listen((data) {\\n        if (_onChange != null) {\\n          _onChange(data);\\n        }\\n      }, onError: onError);\\n\\n    if (initialData != null) {\\n      stream.value = initialData;\\n    }\\n  }\\n", "commentSize": 1088, "codeSize": 383, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// It's the simplest class that implements the [StreamedObject] interface.\\n///\\n/// Every time a new value is set, this is compared to the oldest one and if\\n/// it is different, it is sent to stream.\\n///\\n/// Used in tandem with `ValueBuilder` it automatically triggers the rebuild\\n/// of the widgets returned by its builder.\\n///\\n///\\n/// So for example, instead of:\\n///\\n///\\n/// ```dart\\n/// counter += 1;\\n/// stream.sink.add(counter);\\n/// ```\\n///\\n///\\n/// It becomes just:\\n///\\n///\\n/// ```dart\\n/// counter.value += 1;\\n/// ```\\n///\\n/// It can be used even with `StreamedWidget` and `StreamBuilder` by using its\\n/// stream getter `outStream`.\\n///\\n/// N.B. when the type is not a basic type (e.g int, double, String etc.) and\\n/// the value of a property of the object is changed, it is necessary to call\\n/// the [refresh] method to update the stream.\\n///\\n///\\n/// #### Usage\\n///\\n/// ```dart\\n/// // In the BLoC\\n/// final counter = StreamedValue<int>();\\n///\\n/// incrementCounter() {\\n///   counter.value += 2.0;\\n/// }\\n///\\n///\\n/// // View\\n/// ValueBuilder<int>(\\n///     streamed: bloc.count, // no need of the outStream getter with ValueBuilder\\n///     builder: (context, snapshot) => Text('Value: ${snapshot.data}'),\\n///     noDataChild: Text('NO DATA'),\\n/// ),\\n/// RaisedButton(\\n///     color: buttonColor,\\n///     child: Text('+'),\\n///     onPressed: () {\\n///       bloc.incrementCounter();\\n///     },\\n/// ),\\n///\\n/// // As an alternative:\\n/// //\\n/// // StreamedWidget<int>(\\n/// //   stream: bloc.count.outStream,\\n/// //   builder: (context, snapshot) => Text('Value: ${snapshot.data}'),\\n/// //   noDataChild: Text('NO DATA'),\\n/// //,\\n///\\n/// ```\\n///\\n///\\n/// On update the [timesUpdated] increases showing how many times the\\n/// value has been updated.\\n///\\n///\\n/// N.B. For collections use [StreamedList] and [StreamedMap] instead.\\n///\\n///\\n", "code": "class StreamedValue<T> implements StreamedObject<T> {\\n  StreamedValue({this.initialData, this.onError}) {\\n    stream = BehaviorSubject<T>()\\n      ..stream.listen((e) {\\n        _lastValue = e;\\n        if (_onChange != null) {\\n          _onChange(e);\\n        }\\n      }, onError: onError);\\n\\n    if (initialData != null) {\\n      _lastValue = initialData;\\n      stream.sink.add(_lastValue);\\n    }\\n  }\\n", "commentSize": 1905, "codeSize": 411, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n///\\n/// The MemoryObject has a property to preserve the previous value.\\n///\\n/// The setter checks for the new value, if it is different from the one\\n/// already stored, this one is given [oldValue] before storing and streaming\\n/// the new one.\\n///\\n///\\n///\\n", "code": "class MemoryValue<T> extends StreamedValue<T> {\\n  MemoryValue({T initialData, Function onError})\\n      : super(initialData: initialData, onError: onError);\\n\\n  T _oldValue;\\n\\n  T get oldValue => _oldValue;\\n\\n  @override\\n  set value(T value) {\\n    if (_lastValue != value) {\\n      _oldValue = _lastValue;\\n      _lastValue = value;\\n      stream.add(value);\\n      if (_debugMode) {\\n        timesUpdated++;\\n      }\\n    }\\n  }\\n}\\n", "commentSize": 275, "codeSize": 440, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n///\\n///\\n///\\n/// HistoryObject extends the [MemoryValue] class, adding a [StreamedList].\\n///\\n/// When the current value needs to be stored, the [saveValue] function\\n/// is called to send it to the [_historyStream].\\n///\\n", "code": "class HistoryObject<T> extends MemoryValue<T> {\\n  HistoryObject({T initialData, Function onError})\\n      : super(initialData: initialData, onError: onError);\\n\\n  final _historyStream = StreamedList<T>(initialData: []);\\n\\n  @override\\n  set value(T value) {\\n    if (_lastValue != value) {\\n      _oldValue = _lastValue;\\n      inStream(value);\\n      if (_debugMode) {\\n        timesUpdated++;\\n      }\\n    }\\n  }\\n\\n  ///\\n  /// Getter for the list\\n  ///\\n  List<T> get history => _historyStream.value;\\n\\n  ///\\n  /// Getter for the stream\\n  ///\\n  StreamedValue<List<T>> get historyStream => _historyStream.stream;\\n\\n  ///\\n  /// Function to store the current value to a collection and\\n  /// sending it to stream\\n  ///\\n  void saveValue() {\\n    _historyStream.addElement(value);\\n  }\\n\\n  /// To enable the debug mode\\n  @override\\n  void debugMode() {\\n    _debugMode = true;\\n    _historyStream.debugMode();\\n  }\\n\\n  @override\\n  void dispose() {\\n    super.dispose();\\n    _historyStream.dispose();\\n  }\\n}\\n", "commentSize": 236, "codeSize": 1026, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// Timer refresh time\\n", "code": "const int updateTimerMilliseconds = 17;\\n", "commentSize": 34, "codeSize": 41, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// An object that embeds a timer and a stopwatch.\\n///\\n///\\n/// #### Usage\\n///\\n/// ```dart\\n/// final timerObject = TimerObject();\\n///\\n/// startTimer() {\\n///   timerObject.startTimer();\\n/// }\\n///\\n/// stopTimer() {\\n///   timerObject.stopTimer();\\n/// }\\n///\\n/// getLapTime() {\\n///   timerObject.getLapTime();\\n/// }\\n///\\n/// incrementCounter(Timer t) {\\n///   counter.value += 2.0;\\n/// }\\n///\\n/// startPeriodic() {\\n///   var interval = Duration(milliseconds: 1000);\\n///   timerObject.startPeriodic(interval, incrementCounter);\\n/// }\\n///\\n///```\\n///\\n", "code": "class TimerObject extends StreamedValue<int> {\\n  Timer _timer;\\n\\n  Duration _interval = Duration(milliseconds: updateTimerMilliseconds);\\n\\n  bool isTimerActive = false;\\n\\n  int _time = 0; // milliseconds\\n\\n  /// STOPWATCH\\n  final _stopwatch = Stopwatch();\\n\\n  final _stopwatchStreamed = StreamedValue<int>();\\n\\n  bool isStopwatchActive = false;\\n\\n  @override\\n  set value(int value) {\\n    if (_lastValue != value) {\\n      inStream(value);\\n      if (_debugMode) {\\n        timesUpdated++;\\n      }\\n    }\\n  }\\n\\n  /// GETTERS\\n  ///\\n  int get time => _time;\\n\\n  /// Getter for the stream of the stopwatch\\n  Stream<int> get stopwatchStream => _stopwatchStreamed.outStream;\\n\\n  /// Getter for the stopwatch object\\n  StreamedValue<int> get stopwatch => _stopwatchStreamed;\\n\\n  /// Start timer and stopwatch only if they aren't active\\n  ///\\n  void startTimer() {\\n    if (!isTimerActive) {\\n      _timer = Timer.periodic(_interval, updateTime);\\n      isTimerActive = true;\\n    }\\n\\n    if (!isStopwatchActive) {\\n      _stopwatch.start();\\n      isStopwatchActive = true;\\n    }\\n  }\\n\\n  /// Update the time and send it to stream\\n  ///\\n  void updateTime(Timer t) {\\n    _time = _interval.inMilliseconds * t.tick;\\n    inStream(_time);\\n  }\\n\\n  /// Method to start a periodic function and set the isTimerActive to true\\n  ///\\n  void startPeriodic(Duration interval, Function(Timer) callback) {\\n    if (!isTimerActive) {\\n      _timer = Timer.periodic(interval, callback);\\n      _interval = interval;\\n      isTimerActive = true;\\n    }\\n  }\\n\\n  /// Method to get the lap time\\n  void getLapTime() {\\n    if (isStopwatchActive) {\\n      final milliseconds = _stopwatch.elapsedMilliseconds;\\n      _stopwatchStreamed.value = milliseconds;\\n      _stopwatch\\n        ..reset()\\n        ..start();\\n    }\\n  }\\n\\n  /// Stop timer and stopwatch, and set to false the booleans\\n  void stopTimer() {\\n    if (isTimerActive) {\\n      _timer.cancel();\\n      _time = 0;\\n      inStream(null);\\n      isTimerActive = false;\\n    }\\n    if (isStopwatchActive) {\\n      _stopwatch\\n        ..reset()\\n        ..stop();\\n      isStopwatchActive = false;\\n    }\\n  }\\n\\n  /// Method to reset the timer\\n  void resetTimer() {\\n    _time = 0;\\n    inStream(_time);\\n  }\\n\\n  /// Method to cancel the current timer\\n  void pauseTimer() {\\n    _timer.cancel();\\n  }\\n\\n  @override\\n  void dispose() {\\n    super.dispose();\\n    if (_timer != null) {\\n      _timer.cancel();\\n    }\\n    _stopwatchStreamed.dispose();\\n    _stopwatch.stop();\\n  }\\n}\\n", "commentSize": 580, "codeSize": 2556, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// A particular class the implement the [StreamedObject] interface, to use when\\n/// there is the need of a StreamTransformer (e.g. stream transformation,\\n/// validation of input fields, etc.).\\n///\\n///\\n/// #### Usage\\n///\\n/// From the StreamedMap example:\\n///\\n/// ```dart\\n/// // In the BLoC class\\n///   final streamedKey = StreamedTransformed<String, int>();\\n///\\n///\\n/// // In the constructor of the BLoC class\\n///   streamedKey.setTransformer(validateKey);\\n///\\n///\\n/// // Validation (e.g. in the BLoC or in a mixin class)\\n/// final validateKey =\\n///       StreamTransformer<String, int>.fromHandlers(handleData: (key, sink) {\\n///     var k = int.tryParse(key);\\n///     if (k != null) {\\n///       sink.add(k);\\n///     } else {\\n///       sink.addError('The key must be an integer.');\\n///     }\\n///   });\\n///\\n///\\n/// // In the view:\\n/// StreamBuilder<int>(\\n///             stream: bloc.streamedKey.outTransformed,\\n///             builder: (context, snapshot) {\\n///               return Column(\\n///                 children: <Widget>[\\n///                   Padding(\\n///                     padding: const EdgeInsets.symmetric(\\n///                       vertical: 12.0,\\n///                       horizontal: 20.0,\\n///                     ),\\n///                     child: TextField(\\n///                       style: TextStyle(\\n///                         fontSize: 18.0,\\n///                         color: Colors.black,\\n///                       ),\\n///                       decoration: InputDecoration(\\n///                         labelText: 'Key:',\\n///                         hintText: 'Insert an integer...',\\n///                         errorText: snapshot.error,\\n///                       ),\\n///                       // To avoid the user could insert text use the TextInputType.number\\n///                       // Here is commented to show the error msg.\\n///                       //keyboardType: TextInputType.number,\\n///                       onChanged: bloc.streamedKey.inStream,\\n///                     ),\\n///                   ),\\n///                 ],\\n///               );\\n///             }),\\n/// ```\\n///\\n///\\n///\\n", "code": "class StreamedTransformed<T, S> implements StreamedObject<T> {\\n  StreamedTransformed({this.initialData, this.onError}) {\\n    stream = BehaviorSubject<T>()\\n      ..listen((e) {\\n        _lastValue = e;\\n        if (_onChange != null) {\\n          _onChange(e);\\n        }\\n      }, onError: onError);\\n\\n    if (initialData != null) {\\n      _lastValue = initialData;\\n      stream.sink.add(_lastValue);\\n    }\\n  }\\n", "commentSize": 2194, "codeSize": 419, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// Used to make a one-way tunnel beetween two blocs (from blocA to\\n/// a StremedValue on blocB).\\n///\\n/// #### Usage:\\n///\\n/// 1 - Define a streamed object (e.g. [StreamedValue]) in the blocB\\n///\\n/// ```dart\\n/// final receiverStr = StreamedValue<String>();\\n/// ```\\n///\\n/// 2 - Define a [StreamedSender] in the blocA\\n///\\n/// ```dart\\n/// final tunnelSenderStr = StreamedSender<String>();\\n/// ```\\n///\\n///\\n/// 3 - Set the receiver in the sender on the class the holds the instances\\n/// of the blocs\\n///\\n/// ```dart///\\n/// blocA.tunnelSenderStr.setReceiver(blocB.receiverStr);\\n/// ```\\n///\\n/// 4 - To send data from blocA to bloc B then:\\n///\\n/// ```dart\\n/// tunnelSenderStr.send(\"Text from blocA to blocB\");\\n/// ```\\n", "code": "class StreamedSender<T> {\\n  StreamedSender();\\n\\n  StreamedSender.setReceiver(StreamedValue<T> receiver)\\n      : assert(receiver != null, 'The receiver argument is null.') {\\n    _receiver = receiver;\\n  }\\n\\n  StreamedValue<T> _receiver;\\n\\n  void setReceiver(StreamedValue<T> receiver) {\\n    assert(receiver != null, 'The receiver argument is null.');\\n    _receiver = receiver;\\n  }\\n\\n  void send(T data) {\\n    _receiver.value = data;\\n    if (T is List || T is Map) {\\n      _receiver.refresh();\\n    }\\n  }\\n}\\n", "commentSize": 739, "codeSize": 521, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// Like the StreamedSender, but used with lists.\\n///\\n/// #### Usage\\n///\\n/// 1 - Define a [StreamedList] object in the blocB\\n///\\n/// ```dart\\n///   final receiverList = StreamedList<int>();\\n/// ```\\n///\\n/// 2 - Define a [ListSender] in the blocA\\n///\\n/// ```dart\\n///   final tunnelList = ListSender<int>();\\n/// ```\\n///\\n/// 3 - Set the receiver in the sender on the class the holds\\n///   the instances of the blocs\\n///\\n/// ```dart\\n///   blocA.tunnelList.setReceiver(blocB.receiverList);\\n/// ```\\n///\\n/// 4 - To send data from blocA to bloc B then:\\n///\\n/// ```dart\\n///   tunnelList.send(list);\\n/// ```\\n///\\n", "code": "class ListSender<T> {\\n  ListSender();\\n\\n  ListSender.setReceiver(StreamedList<T> receiver)\\n      : assert(receiver != null, 'The receiver argument is null.') {\\n    _receiver = receiver;\\n  }\\n\\n  StreamedList<T> _receiver;\\n\\n  void setReceiver(StreamedList<T> receiver) {\\n    assert(receiver != null, 'The receiver argument is null.');\\n    _receiver = receiver;\\n  }\\n\\n  void send(List<T> data) {\\n    _receiver.value = data;\\n  }\\n}\\n", "commentSize": 629, "codeSize": 443, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// Like the StreamedList, but used with maps.\\n///\\n/// #### Usage\\n///\\n/// 1 - Define a [StreamedMap]object in the blocB\\n///\\n/// ```dart\\n///   final receiverMap = StreamedMap<int, String>();\\n/// ```\\n///\\n/// 2 - Define a [MapSender] in the blocA\\n///\\n/// ```dart\\n///   final tunnelMap = MapSender<int, String>();\\n/// ```\\n///\\n/// 3 - Set the receiver in the sender on the class the holds\\n///   the instances of the blocs\\n///\\n/// ```dart\\n///   blocA.tunnelMap.setReceiver(blocB.receiverMap);\\n/// ```\\n///\\n/// 4 - To send data from blocA to bloc B then:\\n///\\n/// ```dart\\n///   tunnelMap.send(map);\\n/// ```\\n///\\n", "code": "class MapSender<K, V> {\\n  MapSender();\\n\\n  MapSender.setReceiver(StreamedMap<K, V> receiver)\\n      : assert(receiver != null, 'The receiver argument is null.') {\\n    _receiver = receiver;\\n  }\\n\\n  StreamedMap<K, V> _receiver;\\n\\n  /// Method to set the [StreamedMap] on the other bloc where\\n  /// to send the data\\n  void setReceiver(StreamedMap<K, V> receiver) {\\n    assert(receiver != null, 'The receiver argument is null.');\\n    _receiver = receiver;\\n  }\\n\\n  /// Method to send the data to the StreamedMap set by the [setReceiver]\\n  /// method.\\n  void send(Map<K, V> data) {\\n    _receiver.value = data;\\n  }\\n}\\n", "commentSize": 631, "codeSize": 628, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Interface for all the StreamedObjects\\n///\\n", "code": "abstract class StreamedObject<T> {\\n  /// Getter for the stream exposed by the classes that implement\\n  /// the StreamedObject interface.\\n  Stream<T> get outStream;\\n\\n  /// Getter for the last value emitted by the stream\\n  T get value;\\n}\\n", "commentSize": 53, "codeSize": 244, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Fixed Blur\\n///\\n", "code": "class BlurWidget extends StatelessWidget {\\n  const BlurWidget({\\n    @required this.child,\\n    @required this.sigmaX,\\n    @required this.sigmaY,\\n    Key key,\\n  })  : assert(child != null, 'The child argument is null.'),\\n        assert(sigmaX != null, 'The sigmaX argument is null.'),\\n        assert(sigmaY != null, 'The sigmaY argument is null.'),\\n        super(key: key);\\n\\n  ///\\n  /// Child to blur\\n  ///\\n  final Widget child;\\n\\n  ///\\n  /// Vvalue of the sigmaX parameter of the blur\\n  ///\\n  final double sigmaX;\\n\\n  ///\\n  /// Value of the sigmaY parameter of the blur\\n  ///\\n  final double sigmaY;\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return LayoutBuilder(\\n      builder: (context, constraints) => Stack(\\n        children: <Widget>[\\n          Container(\\n              height: constraints.maxHeight,\\n              width: constraints.maxWidth,\\n              child: child),\\n          ClipRect(\\n            child: BackdropFilter(\\n                filter: ui.ImageFilter.blur(sigmaX: sigmaX, sigmaY: sigmaY),\\n                child: Container(\\n                  height: constraints.maxHeight,\\n                  width: constraints.maxWidth,\\n                  color: Colors.transparent,\\n                )),\\n          ),\\n        ],\\n      ),\\n    );\\n  }\\n}\\n", "commentSize": 26, "codeSize": 1310, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Animated blur\\n///\\n", "code": "class AnimatedBlurWidget extends StatefulWidget {\\n  const AnimatedBlurWidget(\\n      {@required this.child,\\n      Key key,\\n      this.initialSigmaX = 0.0,\\n      this.initialSigmaY = 0.0,\\n      this.finalSigmaX = 4.0,\\n      this.finalSigmaY = 8.0,\\n      this.duration = 5000,\\n      this.reverseAnimation = true,\\n      this.loop = true,\\n      this.refreshTime = blurRefreshTime})\\n      : assert(child != null, 'The child argument is null.'),\\n        super(key: key);\\n\\n  ///\\n  /// Child to blur\\n  ///\\n  final Widget child;\\n\\n  ///\\n  /// Initial value of the sigmaX parameter of the blur\\n  ///\\n  final double initialSigmaX;\\n\\n  ///\\n  /// Initial value of the sigmaY parameter of the blur\\n  ///\\n  final double initialSigmaY;\\n\\n  ///\\n  /// Final value of the sigmaX parameter of the blur\\n  ///\\n  final double finalSigmaX;\\n\\n  ///\\n  /// Final value of the sigmaY parameter of the blur\\n  ///\\n  final double finalSigmaY;\\n\\n  ///\\n  /// Time for the blur to reach the final values\\n  ///\\n  final int duration;\\n\\n  ///\\n  /// Looping animation (default: false)\\n  ///\\n  final bool loop;\\n\\n  ///\\n  /// Refresh time in milliseconds (default: 20)\\n  ///\\n  final int refreshTime;\\n\\n  ///\\n  /// If set to true (default: true), when the max values are reached\\n  /// the animation reverses until the values reaches their initial value\\n  ///\\n  final bool reverseAnimation;\\n\\n  @override\\n  _AnimatedBlurWidgetState createState() {\\n    return _AnimatedBlurWidgetState();\\n  }\\n}\\n", "commentSize": 29, "codeSize": 1507, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Blur in\\n///\\n", "code": "class BlurInWidget extends StatefulWidget {\\n  const BlurInWidget(\\n      {@required this.child,\\n      Key key,\\n      this.initialSigmaX = 4.0,\\n      this.initialSigmaY = 6.0,\\n      this.duration = 5000,\\n      this.refreshTime = blurRefreshTime})\\n      : assert(child != null, 'The child argument is null.'),\\n        super(key: key);\\n\\n  ///\\n  /// Child to blur\\n  ///\\n  final Widget child;\\n\\n  ///\\n  /// Initial value of the sigmaX parameter of the blur\\n  ///\\n  final double initialSigmaX;\\n\\n  ///\\n  /// Initial value of the sigmaY parameter of the blur\\n  ///\\n  final double initialSigmaY;\\n\\n  ///\\n  /// Time for the blur to reach the final values\\n  ///\\n  final int duration;\\n\\n  ///\\n  /// Refresh time in milliseconds (default: 20)\\n  ///\\n  final int refreshTime;\\n\\n  @override\\n  _BlurInWidgetState createState() {\\n    return _BlurInWidgetState();\\n  }\\n}\\n", "commentSize": 23, "codeSize": 887, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Blur out\\n///\\n", "code": "class BlurOutWidget extends StatefulWidget {\\n  const BlurOutWidget(\\n      {@required this.child,\\n      Key key,\\n      this.finalSigmaX = 4.0,\\n      this.finalSigmaY = 6.0,\\n      this.duration = 5000,\\n      this.refreshTime = blurRefreshTime})\\n      : assert(child != null, 'The child argument is null.'),\\n        super(key: key);\\n\\n  ///\\n  /// Child to blur\\n  ///\\n  final Widget child;\\n\\n  ///\\n  /// Final value of the sigmaX parameter of the blur\\n  ///\\n  final double finalSigmaX;\\n\\n  ///\\n  /// Final value of the sigmaY parameter of the blur\\n  ///\\n  final double finalSigmaY;\\n\\n  ///\\n  /// Time for the blur to reach the final values\\n  ///\\n  final int duration;\\n\\n  ///\\n  /// Refresh time in milliseconds (default: 20)\\n  ///\\n  final int refreshTime;\\n\\n  @override\\n  _BlurOutWidgetState createState() {\\n    return _BlurOutWidgetState();\\n  }\\n}\\n", "commentSize": 24, "codeSize": 879, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// Fade out transition widget.\\n///\\n///\\n", "code": "class FadeOutWidget extends StatefulWidget {\\n  const FadeOutWidget(\\n      {@required this.child,\\n      @required this.duration,\\n      Key key,\\n      this.curve = Curves.linear})\\n      : assert(child != null, 'The child argument is null.'),\\n        assert(duration != null, 'The duration argument is null.'),\\n        super(key: key);\\n\\n  final Widget child;\\n  final int duration;\\n  final Curve curve;\\n\\n  @override\\n  _FadeOutWidgetState createState() {\\n    return _FadeOutWidgetState();\\n  }\\n}\\n", "commentSize": 53, "codeSize": 509, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// Fade in transition widget.\\n///\\n///\\n", "code": "class FadeInWidget extends StatefulWidget {\\n  const FadeInWidget(\\n      {@required this.child,\\n      @required this.duration,\\n      Key key,\\n      this.curve = Curves.linear})\\n      : assert(child != null, 'The child argument is null.'),\\n        assert(duration != null, 'The duration argument is null.'),\\n        super(key: key);\\n\\n  final Widget child;\\n  final int duration;\\n  final Curve curve;\\n\\n  @override\\n  _FadeInWidgetState createState() {\\n    return _FadeInWidgetState();\\n  }\\n}\\n", "commentSize": 52, "codeSize": 505, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// Linear cross fading transition between two widgets, it can be used\\n/// with the `StagedObject`.\\n///\\n///\\n", "code": "class LinearTransition extends StatefulWidget {\\n  const LinearTransition({\\n    @required this.firstWidget,\\n    @required this.secondWidget,\\n    @required this.transitionDuration,\\n    Key key,\\n  })  : assert(firstWidget != null, 'The firstWidget argument is null.'),\\n        assert(secondWidget != null, 'The secondWidget argument is null.'),\\n        assert(transitionDuration != null,\\n            'The transitionDuration argument is null.'),\\n        super(key: key);\\n\\n  final Widget firstWidget;\\n  final Widget secondWidget;\\n  final int transitionDuration;\\n\\n  @override\\n  _LinearTransitionState createState() {\\n    return _LinearTransitionState();\\n  }\\n}\\n", "commentSize": 122, "codeSize": 675, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n///\\n/// Cross fading transition between two widgets. This uses the Flutter\\n/// way to make an animation.\\n///\\n///\\n", "code": "class CurvedTransition extends StatefulWidget {\\n  const CurvedTransition(\\n      {@required this.firstWidget,\\n      @required this.secondWidget,\\n      @required this.transitionDuration,\\n      Key key,\\n      this.curve})\\n      : assert(firstWidget != null, 'The firstWidget argument is null.'),\\n        assert(secondWidget != null, 'The secondWidget argument is null.'),\\n        assert(transitionDuration != null,\\n            'The transitionDuration argument is null.'),\\n        super(key: key);\\n\\n  final Widget firstWidget;\\n  final Widget secondWidget;\\n  final int transitionDuration;\\n  final Curve curve;\\n\\n  @override\\n  _CurvedTransitionState createState() {\\n    return _CurvedTransitionState();\\n  }\\n}\\n", "commentSize": 123, "codeSize": 725, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Waves animation\\n///\\n", "code": "class WavesWidget extends StatefulWidget {\\n  const WavesWidget({\\n    @required this.child,\\n    Key key,\\n    this.width,\\n    this.height,\\n    this.color,\\n    this.refreshTime = 20,\\n  })  : assert(child != null, 'The child argument is null.'),\\n        super(key: key);\\n\\n  final double width;\\n  final double height;\\n  final MaterialColor color;\\n  final Widget child;\\n\\n  ///\\n  /// Refresh time in milliseconds (default: 20)\\n  ///\\n  final int refreshTime;\\n\\n  @override\\n  _WavesWidgetState createState() {\\n    return _WavesWidgetState();\\n  }\\n}\\n", "commentSize": 31, "codeSize": 564, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// Interface to extend to define the own app state model\\n/// to use along with the [AppStateProvider]\\n///\\n", "code": "abstract class AppStateModel {\\n  /// This method is called in the `initState` method of the `State` class\\n  /// associated to the [AppStateProvider].\\n  void init();\\n\\n  void dispose();\\n}\\n", "commentSize": 110, "codeSize": 193, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// This class is used to handle the scenes:\\n///\\n", "code": "class Scene {\\n  Scene({this.widget, this.time, this.onShow});\\n\\n  Widget widget;\\n  int time; // milliseconds\\n  Function onShow;\\n}\\n", "commentSize": 56, "codeSize": 136, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Class used in the cross fading between two scenes\\n///\\n", "code": "class SceneBridge {\\n  SceneBridge(this.currentStage, this.old, this.next);\\n\\n  int currentStage;\\n  Scene old;\\n  Scene next;\\n}\\n", "commentSize": 65, "codeSize": 132, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Enum to handle the Status of the ScenesObject\\n///\\n", "code": "enum SceneStatus { active, stop }\\n", "commentSize": 61, "codeSize": 35, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Interval in millisecond to check for the next scene\\n///\\n", "code": "const int updateTimeScenes = 100;\\n", "commentSize": 67, "codeSize": 35, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// A complex class to hadle the rendering of scenes over the time.\\n/// It takes a collection of \"Scenes\" and triggers the visualization of\\n/// the widgets at a given time (relative o absolute timing).\\n/// For example to make a demostration on how to use an application,\\n/// showing the widgets and pages along with explanations.\\n///\\n/// Every scene is handled by using the Scene class:\\n///\\n///```dart\\n/// class Scene {\\n///   Widget widget;\\n///   int time; // milliseconds\\n///   Function onShow = () {};\\n///   Scene({this.widget, this.time, this.onShow});\\n/// }\\n/// ```\\n///\\n/// ##### N.B. The onShow callback is used to trigger an action when the scene shows\\n///\\n/// #### Usage\\n/// From the ScenesObject example:\\n///\\n/// #### 1 - Declare a list of scenes\\n///\\n/// ```dart\\n/// final ScenesObject scenesObject = ScenesObject();\\n/// ```\\n///\\n/// #### 2 - Add some scenes\\n///\\n/// ```dart\\n/// scenes.addAll([\\n///   Scene(\\n///     time: 4000,\\n///     widget: SingleScene(text: 'Scene 1', color: Colors.blueGrey),\\n///     onShow: () => print('Showing scene 1'),\\n///   ),\\n///   Scene(\\n///     time: 4000,\\n///     widget: SingleScene(text: 'Scene 2', color: Colors.orange),\\n///     onShow: () => print('Showing scene 1'),\\n///   )\\n/// ]);\\n///\\n///\\n/// // The singleScene widget:\\n///\\n/// class SingleScene extends StatelessWidget {\\n///   const SingleScene({Key key, this.text, this.color}) : super(key: key);\\n///\\n///   final String text;\\n///   final Color color;\\n///\\n///   @override\\n///   Widget build(BuildContext context) {\\n///     return Container(\\n///       alignment: Alignment.center,\\n///       color: color,\\n///       child: Text(text),\\n///     );\\n///   }\\n/// }\\n/// ```\\n/// #### 3 - Setup the ScenesObject and play the scenes\\n///\\n/// ```dart\\n/// scenesObject\\n///   ..setScenesList(scenes)\\n///   ..setCallback(() => print('Called on start'))\\n///   ..setOnEndCallback(scenesObject.startScenes); // Replay the scenes at the end\\n///\\n/// // For e.g. on tap on a button:\\n/// scenesObject.startScenes();\\n/// ```\\n///\\n///\\n", "code": "class ScenesObject implements StreamedObject {\\n  // Default constructor\\n  ScenesObject({this.absoluteTiming = false, this.callbackOnStart = true}) {\\n    if (absoluteTiming) {\\n      periodic = checkAbsolute;\\n    } else {\\n      periodic = checkRelative;\\n    }\\n  }\\n", "commentSize": 2082, "codeSize": 271, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// This class is used to handle the stages:\\n///\\n", "code": "class Stage {\\n  Stage({this.widget, this.time, this.onShow});\\n\\n  Widget widget;\\n  int time; // milliseconds\\n  Function onShow;\\n}\\n", "commentSize": 56, "codeSize": 136, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Class used in the cross fading between two stages\\n///\\n", "code": "class StageBridge {\\n  StageBridge(this.currentStage, this.old, this.next);\\n\\n  int currentStage;\\n  Stage old;\\n  Stage next;\\n}\\n", "commentSize": 65, "codeSize": 132, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Enum to handle the Status of the StagedObject\\n///\\n", "code": "enum StageStatus { active, stop }\\n", "commentSize": 61, "codeSize": 35, "repo": "frideosapps/frideos_flutter"},
{"comment": "///\\n/// Interval in millisecond to check for the next stage\\n///\\n", "code": "const int updateTimeStaged = 100;\\n", "commentSize": 67, "codeSize": 35, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// A complex class to hadle the rendering of widgets over the time.\\n/// It takes a collection of \"Stages\" and triggers the visualization of\\n/// the widgets at a given time (relative o absolute timing).\\n/// For example to make a demostration on how to use an application,\\n/// showing the widgets and pages along with explanations.\\n///\\n///\\n/// Every stage is handled by using the Stage class:\\n///\\n/// class Stage {\\n///   Widget widget;\\n///   int time; // milliseconds\\n///   Function onShow = () {};\\n///   Stage({this.widget, this.time, this.onShow});\\n/// }\\n/// ```\\n///\\n/// ##### N.B. The onShow callback is used to trigger an action when the\\n/// stage shows\\n///\\n/// #### Usage\\n///\\n/// From the StagedObject example:\\n///\\n/// 1. #### Declare a map <int, Stage>\\n///    Here the map is in the view and is set in the BLoC class by the\\n///    setStagesMap.\\n///\\n/// ```dart\\n/// Map<int, Stage> get stagesMap => <int, Stage>{\\n///   0: Stage(\\n///       widget: Container(\\n///         width: 200.0,\\n///         height: 200.0,\\n///         color: Colors.indigo[200],\\n///         alignment: Alignment.center,\\n///         key: Key('0'),\\n///         child: ScrollingText(\\n///           text:\\n///             'This stage will last 8 seconds. By the onShow call back it is possibile to assign an action when the widget shows.',\\n///           scrollingDuration: 2000,\\n///           style: TextStyle(\\n///             color: Colors.blue,\\n///             fontSize: 18.0,\\n///             fontWeight: FontWeight.w500)),\\n///         ),\\n///       time: 8000,\\n///       onShow: () {}),\\n///  1: Stage(\\n///       widget: Container(\\n///         width: 200.0,\\n///         height: 200.0,\\n///         color: Colors.indigo[200],\\n///         alignment: Alignment.center,\\n///         key: Key('00'),\\n///         child: ScrollingText(\\n///               text: 'The next widgets will cross      fade.',\\n///               scrollingDuration: 2000,\\n///             ),\\n///           ),\\n///       time: 8000,\\n///       onShow: () {}),\\n///\\n/// }\\n/// ```\\n/// 2. #### In the BLoC\\n///\\n/// ```dart\\n///   final text = StreamedValue<String>();\\n///   final staged = StagedObject();\\n///\\n///   // The map can be set through the constructor of the StagedObject\\n///   // or by the setStagesMap method like in this case.\\n///   setMap(Map<int, Stage> stagesMap) {\\n///     staged.setStagesMap(stagesMap);\\n///   }\\n///\\n///   start() {\\n///     if (staged.getMapLength() > 0) {\\n///       staged.setCallback(sendNextStageText);\\n///       staged.startStages();\\n///     }\\n///   }\\n///\\n///\\n///   sendNextStageText() {\\n///     var nextStage = staged.getNextStage();\\n///     if (nextStage != null) {\\n///       text.value = \"Next stage:\";\\n///       widget.value = nextStage.widget;\\n///       stage.value = StageBridge(\\n///           staged.getStageIndex(), staged.getCurrentStage(), nextStage);\\n///     } else {\\n///       text.value = \"This is the last stage\";\\n///       widget.value = Container();\\n///     }\\n///   }\\n/// ```\\n///\\n/// 3. #### In the view:\\n///\\n/// ```dart\\n///   // Setting the map in the build method\\n///   StagedObjectBloc bloc = BlocProvider.of(context);\\n///   bloc.setMap(stagesMap);\\n///\\n///\\n///   // To show the current widget on the view using the ReceiverWidget.\\n///   // As an alternative it can be used the ValueBuilder/StreamBuilder.\\n///   ReceiverWidget(\\n///     stream: bloc.staged.widgetStream,\\n///   ),\\n/// ```\\n///\\n///\\n", "code": "class StagedObject implements StreamedObject {\\n  // Default constructor\\n  StagedObject({this.absoluteTiming = false, this.callbackOnStart = true}) {\\n    if (absoluteTiming) {\\n      periodic = checkAbsolute;\\n    } else {\\n      periodic = checkRelative;\\n    }\\n  }\\n", "commentSize": 3490, "codeSize": 271, "repo": "frideosapps/frideos_flutter"},
{"comment": "/// This class contains the db object that the applications requires.\\n/// For testing, we need to create a Fake Database provider\\n//    Sqflite.devSetDebugModeOn(true);\\n", "code": "class DatabaseProviderImpl implements DatabaseProvider {\\n\\n  static final _instance = DatabaseProviderImpl._internal();\\n  static DatabaseProviderImpl get = _instance;\\n  bool isInitialized = false;\\n  Database? _db;\\n\\n  // private constructor\\n  DatabaseProviderImpl._internal();\\n\\n  Future _init() async {\\n    var databasePath = await getDatabasesPath();\\n    String path = join(databasePath, \"friends_tournament.db\");\\n\\n\\n    _db = await openDatabase(path, version: 1,\\n        onCreate: (Database db, int version) async {\\n      await db.execute(MatchDao().createTableQuery);\\n      await db.execute(MatchSessionDao().createTableQuery);\\n      await db.execute(PlayerDao().createTableQuery);\\n      await db.execute(PlayerSessionDao().createTableQuery);\\n      await db.execute(SessionDao().createTableQuery);\\n      await db.execute(TournamentDao().createTableQuery);\\n      await db.execute(TournamentMatchDao().createTableQuery);\\n      await db.execute(TournamentPlayerDao().createTableQuery);\\n    });\\n  }\\n\\n  @override\\n  Future<Database> db() async {\\n    if (_db == null) await _init();\\n    return _db!;\\n  }\\n\\n  @override\\n  Future<void> closeDb() async {\\n    if (_db != null) {\\n      _db!.close();\\n    }\\n  }\\n}\\n", "commentSize": 172, "codeSize": 1239, "repo": "prof18/friends-tournament"},
{"comment": "/// Get all the matches for the current tournament\\n", "code": "const allMatchesForActiveTournamentQuery =\\n", "commentSize": 52, "codeSize": 44, "repo": "prof18/friends-tournament"},
{"comment": "/// This objects is used to hold all the info about a match that are needed in\\n/// the UI, for example all the session of the match.\\n/// It is an extensions of the [] saved in the db.\\n", "code": "class UIMatch extends tournament.Match {\\n  List<UISession> matchSessions;\\n  bool isSelected = false;\\n\\n  /// If there is at least one player with a score different than zero, it means\\n  /// that that match has been saved once\\n  bool hasAlreadyScore() {\\n    bool hasScore = false;\\n\\n    for (var matchSession in matchSessions) {\\n      final playersWithScore = matchSession.sessionPlayers.where((element) => element.score != 0).toList();\\n      if (playersWithScore.isNotEmpty) {\\n        hasScore = true;\\n      }\\n    }\\n\\n    return hasScore;\\n  }\\n\\n  UIMatch({required this.matchSessions, id, name, isActive, order})\\n      : super(id, name, isActive, order);\\n\\n  tournament.Match getParent() {\\n    return tournament.Match(id, name, isActive, order);\\n  }\\n}\\n", "commentSize": 187, "codeSize": 773, "repo": "prof18/friends-tournament"},
{"comment": "/// This objects is used to hold all the info about a player that is needed in\\n/// the UI, for example the score.\\n/// It is an extensions of the [Player] saved in the db.\\n", "code": "class UIPlayer extends Player {\\n  int score;\\n\\n  UIPlayer({id, name, required this.score}) : super(id, name);\\n}\\n", "commentSize": 174, "codeSize": 116, "repo": "prof18/friends-tournament"},
{"comment": "/// This objects is used to hold all the info about a session that are needed in\\n/// the UI, for example all the players of the sessions.\\n/// It is an extensions of the [Session] saved in the db.\\n", "code": "class UISession extends Session {\\n  List<UIPlayer> sessionPlayers;\\n\\n  UISession({required this.sessionPlayers, id, name, order})\\n      : super(id, name, order);\\n}\\n", "commentSize": 199, "codeSize": 169, "repo": "prof18/friends-tournament"},
{"comment": "/// Different matches compose a tournament\\n/// Only ONE match can be active at the same time\\n/// Correspond to a row of the 'matches' db table. [MatchDao]\\n", "code": "class Match {\\n  String id;\\n  String name;\\n  int isActive;\\n  int order;\\n\\n  Match(this.id, this.name, this.isActive, this.order);\\n\\n  @override\\n  String toString() {\\n    return 'Match{id: $id, name: $name, isActive: $isActive, order: $order}';\\n  }\\n}\\n", "commentSize": 158, "codeSize": 260, "repo": "prof18/friends-tournament"},
{"comment": "/// The session of a specific match\\n/// Correspond to a row of the 'matches_session' db table. [MatchSessionDao]\\n", "code": "class MatchSession {\\n  String matchId;\\n  String sessionId;\\n\\n  MatchSession(this.matchId, this.sessionId);\\n\\n  @override\\n  String toString() {\\n    return 'MatchSession{matchId: $matchId, sessionId: $sessionId}';\\n  }\\n}\\n", "commentSize": 115, "codeSize": 227, "repo": "prof18/friends-tournament"},
{"comment": "/// Correspond to a row of the 'players' db table. [PlayerDao]\\n", "code": "class Player {\\n  String id;\\n  String name;\\n\\n  Player(this.id, this.name);\\n\\n  @override\\n  String toString() {\\n    return 'Player{id: $id, name: $name}';\\n  }\\n}\\n", "commentSize": 64, "codeSize": 169, "repo": "prof18/friends-tournament"},
{"comment": "/// The player of a specific sessions\\n/// Correspond to a row of the 'player_session' db table. [PlayerSessionDao]\\n", "code": "class PlayerSession {\\n  String playerId;\\n  String sessionId;\\n  int score;\\n\\n  PlayerSession(this.playerId, this.sessionId, this.score);\\n\\n  @override\\n  String toString() {\\n    return 'PlayerSession{playerId: $playerId, sessionId: $sessionId, score: $score}';\\n  }\\n}\\n", "commentSize": 117, "codeSize": 275, "repo": "prof18/friends-tournament"},
{"comment": "/// A match is composed by a different number of sessions,\\n/// due to the player at the same time constraint\\n/// Correspond to a row of the 'session' db table. [SessionDao]\\n", "code": "class Session {\\n  String id;\\n  String name;\\n  int order;\\n\\n  Session(this.id, this.name, this.order);\\n\\n  @override\\n  String toString() {\\n    return 'Session{id: $id, name: $name, order: $order}';\\n  }\\n}\\n", "commentSize": 176, "codeSize": 213, "repo": "prof18/friends-tournament"},
{"comment": "/// A tournament is played by [playersNumber] different player and the can be\\n/// a fixed number of players that plays at the same time [playersAstNumber].\\n/// A tournament is composed by different number of matches [matchesNumber].\\n/// Due to the 'player at the same time constraint', a match is divided in sessions.\\n/// Correspond to a row of the 'tournaments' db table [TournamentDao]\\n", "code": "class Tournament {\\n  String id;\\n  String name;\\n  int playersNumber;\\n  int playersAstNumber;\\n  int matchesNumber;\\n  // 0 inactive, 1 active\\n  int isActive;\\n  int date;\\n\\n  Tournament(\\n    this.id,\\n    this.name,\\n    this.playersNumber,\\n    this.playersAstNumber,\\n    this.matchesNumber,\\n    this.isActive,\\n    this.date,\\n  );\\n\\n  @override\\n  String toString() {\\n    return 'Tournament{id: $id, name: $name, playersNumber: $playersNumber, playersAstNumber: $playersAstNumber, matchesNumber: $matchesNumber, isActive: $isActive, date: $date}';\\n  }\\n}\\n", "commentSize": 393, "codeSize": 570, "repo": "prof18/friends-tournament"},
{"comment": "/// The match of a specific tournament\\n/// Correspond to a row of the 'tournament_match' db table. [TournamentMatchDao]\\n", "code": "class TournamentMatch {\\n  String tournamentId;\\n  String matchId;\\n\\n  TournamentMatch(this.tournamentId, this.matchId);\\n\\n  @override\\n  String toString() {\\n    return 'TournamentMatch{tournamentId: $tournamentId, matchId: $matchId}';\\n  }\\n\\n\\n}", "commentSize": 122, "codeSize": 250, "repo": "prof18/friends-tournament"},
{"comment": "/// The player of a specific tournament\\n/// Correspond to a row of the 'tournament_player' db table. [TournamentPlayerDao]\\n", "code": "class TournamentPlayer {\\n  String playerId;\\n  String tournamentId;\\n  int finalScore;\\n\\n  TournamentPlayer(this.playerId, this.tournamentId, this.finalScore);\\n\\n  @override\\n  String toString() {\\n    return 'TournamentPlayer{playerId: $playerId, tournamentId: $tournamentId, finalScore: $finalScore}';\\n  }\\n}\\n", "commentSize": 125, "codeSize": 316, "repo": "prof18/friends-tournament"},
{"comment": "/// A dialog loader with a nice open and close animation.\\n/// In order to control it, you need to create the animation controller outside.\\n/// For example:\\n///\\n/// AnimationController(vsync: this, duration: Duration(milliseconds: 450));\\n///\\n/// N.B. remember to use the mixin on the State:\\n///\\n///   with SingleTickerProviderStateMixin\\n///\\n/// To start the dialog:\\n///\\n///    showDialog(\\n///     context: context,\\n///     barrierDismissible: false,\\n///     builder: (_) => DialogLoader(\\n///       controller: _controller,\\n///       text: \"This is loading something\",\\n///     )\\n///   );\\n///\\n/// To close it, call the reverse animation and then pop the navigation\\n///\\n///   _controller.reverse().then((_) {\\n///     Navigator.pop(context);\\n///   });\\n///\\n", "code": "class DialogLoader extends StatefulWidget {\\n  final String text;\\n  final AnimationController controller;\\n\\n  const DialogLoader({Key? key, required this.text, required this.controller})\\n      : super(key: key);\\n\\n  @override\\n  State<StatefulWidget> createState() => DialogLoaderState();\\n}\\n", "commentSize": 778, "codeSize": 297, "repo": "prof18/friends-tournament"},
{"comment": "/// Adapted from https://github.com/CODEHOMIE/Flutter-Onboarding-UI-Concept/blob/master/lib/widgets/slide_dots.dart\\n", "code": "class SlideDots extends StatelessWidget {\\n  final bool isActive;\\n  const SlideDots(this.isActive, {Key? key}) : super(key: key);\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return AnimatedContainer(\\n      duration: const Duration(milliseconds: 150),\\n      margin: const EdgeInsets.symmetric(horizontal: 3.3),\\n      height: isActive ? 10 : 6,\\n      width: isActive ? 10 : 6,\\n      decoration: BoxDecoration(\\n        color: isActive ? Colors.white : Colors.grey,\\n        border: isActive\\n            ? Border.all(\\n                color: AppColors.blue,\\n                width: 2.0,\\n              )\\n            : Border.all(\\n                color: Colors.transparent,\\n                width: 1,\\n              ),\\n        borderRadius: const BorderRadius.all(Radius.circular(12)),\\n      ),\\n    );\\n  }\\n}\\n", "commentSize": 117, "codeSize": 835, "repo": "prof18/friends-tournament"},
{"comment": "/// Adapted from https://resocoder.com/2019/06/01/flutter-localization-the-easy-way-internationalization-with-json/\\n", "code": "class AppLocalizations {\\n  final Locale locale;\\n\\n  AppLocalizations(this.locale);\\n\\n  // Static member to have a simple access to the delegate from the MaterialApp\\n  static const LocalizationsDelegate<AppLocalizations> delegate =\\n  _AppLocalizationsDelegate();\\n\\n  // Helper method to keep the code in the widgets concise\\n  // Localizations are accessed using an InheritedWidget \"of\" syntax\\n  static AppLocalizations? of(BuildContext context) {\\n    return Localizations.of<AppLocalizations>(context, AppLocalizations);\\n  }\\n\\n  late Map<String, String> _localizedStrings;\\n\\n  Future<bool> load() async {\\n    // Load the language JSON file from the \"lang\" folder\\n    String jsonString =\\n    await rootBundle.loadString('lang/${locale.languageCode}.json');\\n    Map<String, dynamic> jsonMap = json.decode(jsonString);\\n\\n    _localizedStrings = jsonMap.map((key, value) {\\n      return MapEntry(key, value.toString());\\n    });\\n\\n    return true;\\n  }\\n\\n  // This method will be called from every widget which needs a localized text\\n  String _translate(String key) {\\n    return _localizedStrings[key] ?? key;\\n  }\\n\\n  static String translate(BuildContext context, String key) {\\n    return AppLocalizations.of(context)?._translate(key) ?? key;\\n  }\\n}\\n", "commentSize": 117, "codeSize": 1271, "repo": "prof18/friends-tournament"},
{"comment": "// LocalizationsDelegate is a factory for a set of localized resources\\n// In this case, the localized strings will be gotten in an AppLocalizations object\\n", "code": "class _AppLocalizationsDelegate\\n", "commentSize": 157, "codeSize": 33, "repo": "prof18/friends-tournament"},
{"comment": "/// Generate a tournament id from the hash code of \"${DateTime.now()}-$idName\"\\n", "code": "String generateTournamentId(String tournamentName) {\\n  var idName = _generateGenericId(tournamentName);\\n  return \"${DateTime.now()}-$idName\".hashCode.toString();\\n}\\n", "commentSize": 80, "codeSize": 168, "repo": "prof18/friends-tournament"},
{"comment": "/// Generate a match id from the hash code of \"$tournamentId-$idName\"\\n", "code": "String generateMatchId(String? tournamentId, String matchName) {\\n  var idName = _generateGenericId(matchName);\\n  return \"$tournamentId-$idName\".hashCode.toString();\\n}\\n", "commentSize": 71, "codeSize": 171, "repo": "prof18/friends-tournament"},
{"comment": "/// Generate a Session id from the hashCode of \"$matchId-$idName\"\\n", "code": "String generateSessionId(String? matchId, String sessionName) {\\n  var idName = _generateGenericId(sessionName);\\n  return \"$matchId-$idName\".hashCode.toString();\\n}\\n", "commentSize": 67, "codeSize": 167, "repo": "prof18/friends-tournament"},
{"comment": "/// Generate a Player Id starting from the name\\n", "code": "String generatePlayerId(String playerName) {\\n  return _generateGenericId(playerName);\\n}\\n", "commentSize": 49, "codeSize": 91, "repo": "prof18/friends-tournament"},
{"comment": "/// Generate a generic id using hash code\\n", "code": "String _generateGenericId(String name){\\n  return name\\n      .toLowerCase()\\n      .trim()\\n      .replaceAll(\" \", \"\")\\n      .hashCode\\n      .toString();\\n}", "commentSize": 43, "codeSize": 159, "repo": "prof18/friends-tournament"},