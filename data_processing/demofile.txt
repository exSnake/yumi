/// A drawable of a rectangle with a radius.#6149#class RectangleDrawable extends Sized2DDrawable implements ShapeDrawable {   /// The paint to be used for the line drawable.   @override   Paint paint;    /// The border radius of the rectangle.   /// The default value is a circular radius of 5 on all corners.   BorderRadius borderRadius;    /// Creates a new [RectangleDrawable] with the given [size], [paint] and [borderRadius].   RectangleDrawable({     Paint? paint,     required Size size,     required Offset position,     double rotationAngle = 0,     double scale = 1,     Set<ObjectDrawableAssist> assists = const <ObjectDrawableAssist>{},     Map<ObjectDrawableAssist, Paint> assistPaints =         const <ObjectDrawableAssist, Paint>{},     bool locked = false,     bool hidden = false,     this.borderRadius = const BorderRadius.all(Radius.circular(5)),   })  : paint = paint ?? ShapeDrawable.defaultPaint,         super(             size: size,             position: position,             rotationAngle: rotationAngle,             scale: scale,             assists: assists,             assistPaints: assistPaints,             locked: locked,             hidden: hidden);    /// Getter for padding of drawable.   ///   /// Add padding equal to the stroke width of the paint.   @protected   @override   EdgeInsets get padding => EdgeInsets.all(paint.strokeWidth / 2);    /// Draws the arrow on the provided [canvas] of size [size].   @override   void drawObject(Canvas canvas, Size size) {     final drawingSize = this.size * scale;     canvas.drawRRect(         RRect.fromRectAndCorners(           Rect.fromCenter(               center: position,               width: drawingSize.width,               height: drawingSize.height),           topLeft: borderRadius.topLeft,           topRight: borderRadius.topRight,           bottomLeft: borderRadius.bottomLeft,           bottomRight: borderRadius.bottomRight,         ),         paint);   }    /// Creates a copy of this but with the given fields replaced with the new values.   @override   RectangleDrawable copyWith({     bool? hidden,     Set<ObjectDrawableAssist>? assists,     Offset? position,     double? rotation,     double? scale,     Size? size,     Paint? paint,     bool? locked,     BorderRadius? borderRadius,   }) {     return RectangleDrawable(       hidden: hidden ?? this.hidden,       assists: assists ?? this.assists,       position: position ?? this.position,       rotationAngle: rotation ?? rotationAngle,       scale: scale ?? this.scale,       size: size ?? this.size,       paint: paint ?? this.paint,       locked: locked ?? this.locked,       borderRadius: borderRadius ?? this.borderRadius,     );   }    /// Calculates the size of the rendered object.   @override   Size getSize({double minWidth = 0.0, double maxWidth = double.infinity}) {     final size = super.getSize();     return Size(size.width, size.height);   }
/// Abstract class representing a drawable of a shape.#6149#abstract class ShapeDrawable extends ObjectDrawable {   /// Default value for [paint].   static final defaultPaint = Paint()     ..strokeWidth = 2     ..color = const Color(0xFF000000)     ..style = PaintingStyle.stroke     ..strokeCap = StrokeCap.round;    /// The paint to be used for the shape drawable.   Paint paint;    /// Default constructor for [ObjectDrawable].   ShapeDrawable({     Paint? paint,     required Offset position,     double rotationAngle = 0,     double scale = 1,     Set<ObjectDrawableAssist> assists = const <ObjectDrawableAssist>{},     Map<ObjectDrawableAssist, Paint> assistPaints =         const <ObjectDrawableAssist, Paint>{},     bool locked = false,     bool hidden = false,   })  : paint = paint ?? defaultPaint,         super(             position: position,             rotationAngle: rotationAngle,             scale: scale,             assists: assists,             assistPaints: assistPaints,             locked: locked,             hidden: hidden);    /// Creates a copy of this but with the given fields replaced with the new values.   @override   ShapeDrawable copyWith({     bool? hidden,     Set<ObjectDrawableAssist>? assists,     Offset? position,     double? rotation,     double? scale,     Paint? paint,     bool? locked,   }); }
/// An event representing the controller requesting to add a new [TextDrawable] to the painter.#6149#class AddTextPainterEvent extends PainterEvent {   /// Creates an [AddTextPainterEvent].   const AddTextPainterEvent(); }
/// Abstract class to represent events that the controller can dispatch to any listeners.#6149#@immutable
/// An event representing the select object drawable being deleted.#6149#class SelectedObjectDrawableRemovedEvent extends PainterEvent {   /// Creates an [SelectedObjectDrawableRemovedEvent].   const SelectedObjectDrawableRemovedEvent(); }
/// A [ArrowDrawable] factory.#6149#class ArrowFactory extends ShapeFactory<ArrowDrawable> {   /// The size of the arrow head to be used in created [ArrowDrawable]s.   double? arrowHeadSize;    /// Creates an instance of [ArrowFactory] with the given [arrowHeadSize].   ArrowFactory({this.arrowHeadSize}) : super();    /// Creates and returns a [ArrowDrawable] with length of 0 and the passed [position] and [paint].   @override   ArrowDrawable create(Offset position, [Paint? paint]) {     return ArrowDrawable(         length: 0,         position: position,         paint: paint,         arrowHeadSize: arrowHeadSize);   } }
/// A [DoubleArrowDrawable] factory.#6149#class DoubleArrowFactory extends ShapeFactory<DoubleArrowDrawable> {   /// The size of the arrow head to be used in created [DoubleArrowDrawable]s.   double? arrowHeadSize;    /// Creates an instance of [DoubleArrowDrawable] with the given [arrowHeadSize].   DoubleArrowFactory({this.arrowHeadSize}) : super();    /// Creates and returns a [DoubleArrowDrawable] with length of 0 and the passed [position] and [paint].   @override   DoubleArrowDrawable create(Offset position, [Paint? paint]) {     return DoubleArrowDrawable(         length: 0,         position: position,         paint: paint,         arrowHeadSize: arrowHeadSize);   } }
/// A [LineDrawable] factory.#6149#class LineFactory extends ShapeFactory<LineDrawable> {   /// Creates an instance of [LineFactory].   LineFactory() : super();    /// Creates and returns a [LineDrawable] with length of 0 and the passed [position] and [paint].   @override   LineDrawable create(Offset position, [Paint? paint]) {     return LineDrawable(length: 0, position: position, paint: paint);   } }
/// A [OvalDrawable] factory.#6149#class OvalFactory extends ShapeFactory<OvalDrawable> {   /// Creates an instance of [OvalFactory].   OvalFactory() : super();    /// Creates and returns a [OvalDrawable] of zero size and the passed [position] and [paint].   @override   OvalDrawable create(Offset position, [Paint? paint]) {     return OvalDrawable(size: Size.zero, position: position, paint: paint);   } }
/// A [RectangleDrawable] factory.#6149#class RectangleFactory extends ShapeFactory<RectangleDrawable> {   /// The border radius of the [RectangleDrawable]s created by this factory.   BorderRadius? borderRadius;    /// Creates an instance of [RectangleFactory].   RectangleFactory({this.borderRadius});    /// Creates and returns a [RectangleDrawable] of zero size and the passed [position] and [paint].   @override   RectangleDrawable create(Offset position, [Paint? paint]) {     final borderRadius = this.borderRadius;     if (borderRadius != null) {       return RectangleDrawable(           size: Size.zero,           position: position,           borderRadius: borderRadius,           paint: paint);     }     return RectangleDrawable(size: Size.zero, position: position, paint: paint);   } }
/// An abstract class that defines an object that can create shape drawables.#6149#abstract class ShapeFactory<T extends ShapeDrawable> {   /// Creates an instance of [ShapeFactory].   const ShapeFactory();    /// Creates the desired shape drawable.   /// Inheriting classes must override this method to create the appropriate [ShapeDrawable].   T create(Offset position, [Paint? paint]); }
/// Custom BoxShadow that can be passed its [BlurStyle]. /// /// This is used to show an outer shadow blur for object controls.#6149#class BorderBoxShadow extends BoxShadow {   /// The blur style to use.   final BlurStyle blurStyle;    /// Creates a new [BorderBoxShadow] with the given `blurStyle` and other arguments matching [BoxShadow].   const BorderBoxShadow({     Color color = const Color(0xFF000000),     Offset offset = Offset.zero,     double blurRadius = 0.0,     double spreadRadius = 0.0,     this.blurStyle = BlurStyle.outer,   }) : super(             color: color,             offset: offset,             blurRadius: blurRadius,             spreadRadius: spreadRadius);    /// Create the [Paint] object that corresponds to this shadow description.   ///   /// This is an overridden method that uses the passed [blurStyle] instead of defaulting to [BlurStyle.normal].   @override   Paint toPaint() {     final Paint result = Paint()       ..color = color       ..maskFilter = MaskFilter.blur(blurStyle, blurSigma);     assert(() {       if (debugDisableShadows) result.maskFilter = null;       return true;     }());     return result;   } }
/// ignore: avoid_web_libraries_in_flutter#6149#import 'dart:js' as js; /// Check Javascript for the renderer.#6149#bool get usingHtmlRenderer => js.context['flutterCanvasKit'] == null;
/// A notification that is dispatched when a drawable is created internally in Flutter Painter.#6149#class DrawableCreatedNotification extends DrawableNotification<Drawable> {   /// Creates a [DrawableCreatedNotification] with the given [drawable].   DrawableCreatedNotification(drawable) : super(drawable); }
/// A notification that is dispatched when a drawable is deleted internally in Flutter Painter.#6149#class DrawableDeletedNotification extends DrawableNotification<Drawable> {   /// Creates a [DrawableDeletedNotification] with the given [drawable].   DrawableDeletedNotification(drawable) : super(drawable); }
/// Abstract class that defines any [FlutterPainterNotification] that targets a [Drawable].#6149#abstract class DrawableNotification<T extends Drawable?>
/// Abstract class that defines [Notification]s used by Flutter Painter. /// /// These notifications are used internally.#6149#abstract class FlutterPainterNotification extends Notification {   /// Default constructor.   const FlutterPainterNotification(); }
/// A notification that is dispatched when the selected [ObjectDrawable] of ObjectWidget is reselected. /// /// This means that if the object drawable is selected and it is tapped/clicked on, this notification is dispatched.#6149#class ObjectDrawableReselectedNotification
/// A notification that is dispatched when the selected [ObjectDrawable] of ObjectWidget changes. /// /// Note that [drawable] will only be valid until the drawable is modified (moved, scaled, rotated, etc...), /// so use this callback as a reference that the selected object drawable changed internally and nothing /// more to avoid issues. /// /// Use [PainterController.selectedObjectDrawable] if you want to do any operations on the selected object drawable.#6149#class SelectedObjectDrawableUpdatedNotification
/// A notification that is dispatched when the [PainterSettings] are changed internally.#6149#class SettingsUpdatedNotification extends FlutterPainterNotification {   /// The new settings.   PainterSettings settings;    /// Creates a [SettingsUpdatedNotification] with the given [settings].   SettingsUpdatedNotification(this.settings); }
/// Represents settings used to create and draw free-style drawables.#6149#@immutable /// Enum representing different states that free-style painting can be.#6149#enum FreeStyleMode {   /// Free-style painting is disabled.   none,    /// Free-style painting is enabled in drawing mode; used to draw scribbles.   draw,    /// Free-style painting is enabled in erasing mode; used to erase drawings.   erase, }
/// Represents the possible haptic feedback settings.#6149#enum HapticFeedbackSettings {   /// No haptic feedback.   none,    /// Light haptic feedback impact.   light,    /// Medium haptic feedback impact.   medium,    /// Heavy haptic feedback impact.   heavy } /// An extension to add a method that performs the haptic feedback impact.#6149#extension HapticFeedbackSettingsImpact on HapticFeedbackSettings {   /// Performs the haptic feedback impact of the [HapticFeedbackSettings].   Future<void> impact() async {     switch (this) {       case HapticFeedbackSettings.none:         break;       case HapticFeedbackSettings.light:         await HapticFeedback.lightImpact();         break;       case HapticFeedbackSettings.medium:         await HapticFeedback.mediumImpact();         break;       case HapticFeedbackSettings.heavy:         await HapticFeedback.heavyImpact();         break;     }   } }
/// Represents settings used to control object drawables in the UI#6149#@immutable /// Represents settings that control the behavior of layout assist for objects. /// /// Layout assist helps in arranging objects by snapping them to common arrangements /// (such as vertical and horizontal centers, right angle rotations, etc...).#6149#@immutable
/// Represents all the settings used to create and draw drawables.#6149#@immutable
/// Represents the settings of scaling the FlutterPainter.#6149#@immutable
/// Represents settings used to control shape drawables in the UI#6149#class ShapeSettings {   /// A factory for the shape in the UI.   /// If this is not null, whenever the user drags on the UI, a shape from the factory is drawn.   final ShapeFactory? factory;    /// If the shape should be drawn once or continuously.   /// If `true`, after the shape is drawn, the [factory] will be set back to `null`.   /// If `false`, the user will be able to keep drawing shapes until [factory] is set to `null` explicitly.   final bool drawOnce;    /// The paint to be used when new shapes are drawn.   /// If `null`, the [ShapeDrawable.defaultPaint] will be used.   final Paint? paint;    /// Creates a new instance of [ShapeSettings] with the given [factory].   const ShapeSettings({     this.factory,     this.drawOnce = true,     this.paint,   });    /// Creates a copy of this but with the given fields replaced with the new values.   ShapeSettings copyWith({     ShapeFactory? factory = _NoShapePassedFactory.instance,     bool? drawOnce,     Paint? paint,   }) =>       ShapeSettings(         factory:             factory == _NoShapePassedFactory.instance ? this.factory : factory,         drawOnce: drawOnce ?? this.drawOnce,         paint: paint ?? this.paint,       ); } /// Private class that is used internally to represent no /// [ShapeFactory] argument passed for [ShapeSettings.copyWith].#6149#class _NoShapePassedFactory extends ShapeFactory {   /// Single instance.   static const _NoShapePassedFactory instance = _NoShapePassedFactory._();    /// Private constructor.   const _NoShapePassedFactory._();    /// Unimplemented implementation of the create method.   @override   ShapeDrawable create(Offset position, [Paint? paint]) {     throw UnimplementedError();   } }
/// Represents settings used to create and draw text.#6149#@immutable
/// Adds a method to get a [ui.Image] object from any [ImageProvider].#6149#extension ImageProviderUiImageGetter on ImageProvider {   /// Returns an [ui.Image] object containing the image data from `this` object.   Future<ui.Image> get image async {     // Used to convert listener callback to future     final completer = Completer<ui.Image>();      // Resolve the image as an [ImageStream] and listen to the stream     resolve(ImageConfiguration.empty)         .addListener(ImageStreamListener((info, _) {       // Assign the [ui.Image] from the image information streamed as the completer value       // When the image from the stream arrives, the completer is completed       completer.complete(info.image);     }));      // Wait for the image data from the completer to arrive from the callback     return await completer.future;   } }
/// Adds extra getters and setters in [PainterController] to make it easier to use. /// /// This was made as an extension to not clutter up the [PainterController] class even more.#6149#extension PainterControllerHelper on PainterController {   /// The current painter settings directly from `value`.   PainterSettings get settings => value.settings;    /// The current background drawable directly from `value`.   BackgroundDrawable? get background => value.background;    /// The unmodifiable list of drawables directly from `value`.   List<Drawable> get drawables => value.drawables;    /// The object settings directly from the painter settings.   ObjectSettings get objectSettings => settings.object;    /// The text settings directly from the painter settings.   TextSettings get textSettings => settings.text;    /// The free-style settings directly from the painter settings.   FreeStyleSettings get freeStyleSettings => settings.freeStyle;    /// The shape settings directly from the painter settings.   ShapeSettings get shapeSettings => settings.shape;    /// The scale settings directly from the painter settings.   ScaleSettings get scaleSettings => settings.scale;    /// The current painter settings directly from `value`.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set settings(PainterSettings settings) =>       value = value.copyWith(settings: settings);    /// The current background drawable directly from `value`.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set background(BackgroundDrawable? background) => value = value.copyWith(         background: background,       );    /// The object settings directly from the painter settings.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set objectSettings(ObjectSettings objectSettings) => value = value.copyWith(           settings: settings.copyWith(         object: objectSettings,       ));    /// The text settings directly from the painter settings.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set textSettings(TextSettings textSettings) => value = value.copyWith(           settings: settings.copyWith(         text: textSettings,       ));    /// The free-style settings directly from the painter settings.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set freeStyleSettings(FreeStyleSettings freeStyleSettings) =>       value = value.copyWith(           settings: settings.copyWith(         freeStyle: freeStyleSettings,       ));    /// The shape settings directly from the painter settings.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set shapeSettings(ShapeSettings shapeSettings) => value = value.copyWith(           settings: settings.copyWith(         shape: shapeSettings,       ));    /// The scale settings directly from the painter settings.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set scaleSettings(ScaleSettings scaleSettings) => value = value.copyWith(           settings: settings.copyWith(         scale: scaleSettings,       ));    /// The function used to decide whether to enlarge the object controls or not from `value.settings.object` directly.   ObjectEnlargeControlsResolver get enlargeObjectControlsResolver =>       value.settings.object.enlargeControlsResolver;    /// The layout-assist settings of the selected object drawable from `value.settings.object` directly.   ObjectLayoutAssistSettings get objectLayoutAssist =>       value.settings.object.layoutAssist;    /// The function used to decide whether to show scale and rotation object controls or not from `value.settings.object` directly.   ObjectShowScaleRotationControlsResolver       get showObjectScaleRotationControlsResolver =>           value.settings.object.showScaleRotationControlsResolver;    /// The text style to be used for text drawables from `value.settings.text` directly.   TextStyle get textStyle => value.settings.text.textStyle;    /// The focus node used to edit text drawables text from `value.settings.text` directly.   FocusNode? get textFocusNode => value.settings.text.focusNode;    /// The free-style painting mode from `value.settings.freeStyle` directly.   FreeStyleMode get freeStyleMode => value.settings.freeStyle.mode;    /// The stroke width used for free-style drawing from `value.settings.freeStyle` directly.   double get freeStyleStrokeWidth => value.settings.freeStyle.strokeWidth;    /// The color used for free-style drawing from `value.settings.freeStyle` directly.   Color get freeStyleColor => value.settings.freeStyle.color;    /// The paint used to draw shapes from `value.settings.shape` directly.   Paint? get shapePaint => value.settings.shape.paint;    /// Whether to draw shapes once or continuously from `value.settings.shape` directly.   bool get drawShapeOnce => value.settings.shape.drawOnce;    /// The factory for the shape to be drawn from `value.settings.shape` directly.   ShapeFactory? get shapeFactory => value.settings.shape.factory;    /// The minimum scale that the user can "zoom out" to from `value.settings.scale` directly.   double get minScale => value.settings.scale.minScale;    /// The maximum scale that the user can "zoom in" to from `value.settings.scale` directly.   double get maxScale => value.settings.scale.maxScale;    /// Whether scaling is enabled or not from `value.settings.scale` directly.   bool get scalingEnabled => value.settings.scale.enabled;    /// The function used to decide whether to enlarge the object controls or not from `value.settings.object` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set enlargeObjectControlsResolver(           ObjectEnlargeControlsResolver enlargeControls) =>       value = value.copyWith(           settings: value.settings.copyWith(               object: value.settings.object.copyWith(         enlargeControlsResolver: enlargeControls,       )));    /// The layout-assist settings of the selected object drawable from `value.settings.object` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set objectLayoutAssist(ObjectLayoutAssistSettings layoutAssist) =>       value = value.copyWith(           settings: value.settings.copyWith(               object: value.settings.object.copyWith(         layoutAssist: layoutAssist,       )));    /// The function used to decide whether to show scale and rotation object controls or not from `value.settings.object` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set showObjectScaleRotationControlsResolver(           ObjectShowScaleRotationControlsResolver               showScaleRotationControlsResolver) =>       value = value.copyWith(           settings: value.settings.copyWith(               object: value.settings.object.copyWith(         showScaleRotationControlsResolver: showScaleRotationControlsResolver,       )));    /// The text style to be used for text drawables from `value.settings.text` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set textStyle(TextStyle textStyle) => value = value.copyWith(       settings: value.settings           .copyWith(text: value.settings.text.copyWith(textStyle: textStyle)));    /// The focus node used to edit text drawables text from `value.settings.text` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set textFocusNode(FocusNode? focusNode) => value = value.copyWith(       settings: value.settings           .copyWith(text: value.settings.text.copyWith(focusNode: focusNode)));    /// The free-style painting mode from `value.settings.freeStyle` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set freeStyleMode(FreeStyleMode mode) => value = value.copyWith(           settings: value.settings.copyWith(               freeStyle: value.settings.freeStyle.copyWith(         mode: mode,       )));    /// The stroke width used for free-style drawing from `value.settings.freeStyle` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set freeStyleStrokeWidth(double strokeWidth) => value = value.copyWith(           settings: value.settings.copyWith(               freeStyle: value.settings.freeStyle.copyWith(         strokeWidth: strokeWidth,       )));    /// The color used for free-style drawing from `value.settings.freeStyle` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set freeStyleColor(Color color) => value = value.copyWith(           settings: value.settings.copyWith(               freeStyle: value.settings.freeStyle.copyWith(         color: color,       )));    /// The paint used to draw shapes from `value.settings.shape` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set shapePaint(Paint? paint) => value = value.copyWith(           settings: value.settings.copyWith(               shape: value.settings.shape.copyWith(         paint: paint,       )));    /// Whether to draw shapes once or continuously from `value.settings.shape` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set drawShapeOnce(bool drawOnce) => value = value.copyWith(           settings: value.settings.copyWith(               shape: value.settings.shape.copyWith(         drawOnce: drawOnce,       )));    /// The factory for the shape to be drawn from `value.settings.shape` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set shapeFactory(ShapeFactory? factory) => value = value.copyWith(           settings: value.settings.copyWith(               shape: value.settings.shape.copyWith(         factory: factory,       )));    /// The minimum scale that the user can "zoom out" to from `value.settings.scale` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set minScale(double minScale) => value = value.copyWith(       settings: value.settings           .copyWith(scale: value.settings.scale.copyWith(minScale: minScale)));    /// The maximum scale that the user can "zoom in" to from `value.settings.scale` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set maxScale(double maxScale) => value = value.copyWith(       settings: value.settings           .copyWith(scale: value.settings.scale.copyWith(maxScale: maxScale)));    /// Whether scaling is enabled or not from `value.settings.scale` directly.   ///   /// Setting this will notify all the listeners of this [PainterController]   /// that they need to update (it calls [notifyListeners]). For this reason,   /// this value should only be set between frames, e.g. in response to user   /// actions, not during the build, layout, or paint phases.   set scalingEnabled(bool enabled) => value = value.copyWith(       settings: value.settings           .copyWith(scale: value.settings.scale.copyWith(enabled: enabled))); }
/// Extension to add a copy method for [Paint].#6149#extension PaintCopy on Paint {   /// Creates a copy of this but with the given fields replaced with the new values.   Paint copyWith({     BlendMode? blendMode,     Color? color,     ColorFilter? colorFilter,     FilterQuality? filterQuality,     ImageFilter? imageFilter,     bool? invertColors,     bool? isAntiAlias,     MaskFilter? maskFilter,     Shader? shader,     StrokeCap? strokeCap,     StrokeJoin? strokeJoin,     double? strokeMiterLimit,     double? strokeWidth,     PaintingStyle? style,   }) {     var paint = Paint()       ..blendMode = blendMode ?? this.blendMode       ..color = color ?? this.color       ..colorFilter = colorFilter ?? this.colorFilter       ..filterQuality = filterQuality ?? this.filterQuality       ..imageFilter = imageFilter ?? this.imageFilter       ..invertColors = invertColors ?? this.invertColors       ..isAntiAlias = isAntiAlias ?? this.isAntiAlias       ..maskFilter = maskFilter ?? this.maskFilter       ..shader = shader ?? this.shader       ..strokeCap = strokeCap ?? this.strokeCap       ..strokeJoin = strokeJoin ?? this.strokeJoin       ..strokeWidth = strokeWidth ?? this.strokeWidth       ..style = style ?? this.style;      if (!usingHtmlRenderer) {       paint.strokeMiterLimit = strokeMiterLimit ?? this.strokeMiterLimit;     }      return paint;   } }
/// Adds a method to convert any [ui.Image] to a [Uint8List] using /// the `ui.ImageByteFormat.png` (png) format.#6149#extension UiImagePngUint8ListGetter on ui.Image {   /// Returns the image byte data from the `this` as a [Uint8List] in png format.   Future<Uint8List?> get pngBytes async {     // Convert this image into byte data with the png format     final byteData = await toByteData(format: ui.ImageByteFormat.png);      // Return the Uint8List from the byte data buffer (if not null)     return byteData?.buffer.asUint8List();   } }
/// Painter that paints the drawables.#6149#class Painter extends CustomPainter {   /// The background drawable to be used as a background.   ///   /// If it is `null`, the painter will have a transparent background.   final BackgroundDrawable? background;    /// List of drawables to be painted.   final List<Drawable> drawables;    /// Size that the drawables will be scaled to.   /// If it is null, the drawables will be drawn without scaling.   final Size? scale;    /// Creates a [Painter] that paints the [drawables] onto a background [background].   const Painter({     required this.drawables,     this.background,     this.scale,   });    /// Paints the drawables onto the [canvas] of size [size].   @override   void paint(Canvas canvas, Size size) {     // This is to allow [_scale] to be upgraded to non-nullable after checking for null     final _scale = scale;      // Draw the background if it was provided     if (background != null && background!.isNotHidden) {       background!.draw(canvas, size);     }      // If a scale size is being used, save the canvas (with the background), scale it     // and then proceed to drawing the drawables     if (_scale != null) {       canvas.save();       canvas.transform(Matrix4.identity()           .scaled(size.width / _scale.width, size.height / _scale.height)           .storage);     }      canvas.saveLayer(Rect.largest, Paint());      // Draw all the drawables     for (final drawable         in drawables.where((drawable) => drawable.isNotHidden)) {       drawable.draw(canvas, _scale ?? size);     }      canvas.restore();      // If a scale size is being used, restore the saved canvas, which will scale all the drawn drawables     if (_scale != null) {       canvas.restore();     }   }    @override   bool shouldRepaint(covariant CustomPainter oldDelegate) {     // Unnecessary check to enforce the [Painter] type     if (oldDelegate is! Painter) return true;      // If the background changed, or any of the drawables changed, a repaint is needed     return oldDelegate.background != background ||         !const ListEquality().equals(oldDelegate.drawables, drawables);   } }
/// Defines the builder used with [FlutterPainter.builder] constructor.#6149#typedef FlutterPainterBuilderCallback = Widget Function( /// Widget that allows user to draw on it#6149#class FlutterPainter extends StatelessWidget {   /// The controller for this painter.   final PainterController controller;    /// Callback when a [Drawable] is created internally in [FlutterPainter].   final DrawableCreatedCallback? onDrawableCreated;    /// Callback when a [Drawable] is deleted internally in [FlutterPainter].   final DrawableDeletedCallback? onDrawableDeleted;    /// Callback when the selected [ObjectDrawable] changes.   final ValueChanged<ObjectDrawable?>? onSelectedObjectDrawableChanged;    /// Callback when the [PainterSettings] of [PainterController] are updated internally.   final ValueChanged<PainterSettings>? onPainterSettingsChanged;    /// The builder used to build this widget.   ///   /// Using the default constructor, it will default to returning the [_FlutterPainterWidget].   ///   /// Using the [FlutterPainter.builder] constructor, the user can define their own builder and build their own   /// UI around [_FlutterPainterWidget], which gets re-built automatically when necessary.   final FlutterPainterBuilderCallback _builder;    /// Creates a [FlutterPainter] with the given [controller] and optional callbacks.   const FlutterPainter(       {Key? key,       required this.controller,       this.onDrawableCreated,       this.onDrawableDeleted,       this.onSelectedObjectDrawableChanged,       this.onPainterSettingsChanged})       : _builder = _defaultBuilder,         super(key: key);    /// Creates a [FlutterPainter] with the given [controller], [builder] and optional callbacks.   ///   /// Using this constructor, the [builder] will be called any time the [controller] updates.   /// It is useful if you want to build UI that automatically rebuilds on updates from [controller].   const FlutterPainter.builder(       {Key? key,       required this.controller,       required FlutterPainterBuilderCallback builder,       this.onDrawableCreated,       this.onDrawableDeleted,       this.onSelectedObjectDrawableChanged,       this.onPainterSettingsChanged})       : _builder = builder,         super(key: key);    @override   Widget build(BuildContext context) {     return PainterControllerWidget(       controller: controller,       child: ValueListenableBuilder<PainterControllerValue>(           valueListenable: controller,           builder: (context, value, child) {             return _builder(                 context,                 _FlutterPainterWidget(                   key: controller.painterKey,                   controller: controller,                   onDrawableCreated: onDrawableCreated,                   onDrawableDeleted: onDrawableDeleted,                   onPainterSettingsChanged: onPainterSettingsChanged,                   onSelectedObjectDrawableChanged:                       onSelectedObjectDrawableChanged,                 ));           }),     );   }    /// The default builder that is used when the default [FlutterPainter] constructor is used.   static Widget _defaultBuilder(BuildContext context, Widget painter) {     return painter;   } } /// The actual widget that displays and allows control for all drawables.#6149#class _FlutterPainterWidget extends StatelessWidget {   /// The controller for this painter.   final PainterController controller;    /// Callback when a [Drawable] is created internally in [FlutterPainter].   final DrawableCreatedCallback? onDrawableCreated;    /// Callback when a [Drawable] is deleted internally in [FlutterPainter].   final DrawableDeletedCallback? onDrawableDeleted;    /// Callback when the selected [ObjectDrawable] changes.   final ValueChanged<ObjectDrawable?>? onSelectedObjectDrawableChanged;    /// Callback when the [PainterSettings] of [PainterController] are updated internally.   final ValueChanged<PainterSettings>? onPainterSettingsChanged;    /// Creates a [_FlutterPainterWidget] with the given [controller] and optional callbacks.   const _FlutterPainterWidget(       {Key? key,       required this.controller,       this.onDrawableCreated,       this.onDrawableDeleted,       this.onSelectedObjectDrawableChanged,       this.onPainterSettingsChanged})       : super(key: key);    @override   Widget build(BuildContext context) {     return Navigator(         onGenerateRoute: (settings) => PageRouteBuilder(             settings: settings,             opaque: false,             pageBuilder: (context, animation, secondaryAnimation) {               final controller = PainterController.of(context);               return NotificationListener<FlutterPainterNotification>(                 onNotification: onNotification,                 child: InteractiveViewer(                   transformationController: controller.transformationController,                   minScale: controller.settings.scale.enabled                       ? controller.settings.scale.minScale                       : 1,                   maxScale: controller.settings.scale.enabled                       ? controller.settings.scale.maxScale                       : 1,                   panEnabled: controller.settings.scale.enabled &&                       (controller.freeStyleSettings.mode == FreeStyleMode.none),                   scaleEnabled: controller.settings.scale.enabled,                   child: _FreeStyleWidget(                       // controller: controller,                       child: _TextWidget(                     // controller: controller,                     child: _ShapeWidget(                       // controller: controller,                       child: _ObjectWidget(                         // controller: controller,                         interactionEnabled: true,                         child: CustomPaint(                           painter: Painter(                             drawables: controller.value.drawables,                             background: controller.value.background,                           ),                         ),                       ),                     ),                   )),                 ),               );             }));   }    /// Handles all notifications that might be dispatched from children.   bool onNotification(FlutterPainterNotification notification) {     if (notification is DrawableCreatedNotification) {       onDrawableCreated?.call(notification.drawable);     } else if (notification is DrawableDeletedNotification) {       onDrawableDeleted?.call(notification.drawable);     } else if (notification is SelectedObjectDrawableUpdatedNotification) {       onSelectedObjectDrawableChanged?.call(notification.drawable);     } else if (notification is SettingsUpdatedNotification) {       onPainterSettingsChanged?.call(notification.settings);     }     return true;   } }
/// Flutter widget to detect user input and request drawing [FreeStyleDrawable]s.#6149#class _FreeStyleWidget extends StatefulWidget {   /// Child widget.   final Widget child;    /// Creates a [_FreeStyleWidget] with the given [controller], [child] widget.   const _FreeStyleWidget({     Key? key,     required this.child,   }) : super(key: key);    @override   _FreeStyleWidgetState createState() => _FreeStyleWidgetState(); } /// State class#6149#class _FreeStyleWidgetState extends State<_FreeStyleWidget> {   /// The current drawable being drawn.   PathDrawable? drawable;    @override   Widget build(BuildContext context) {     if (settings.mode == FreeStyleMode.none || shapeSettings.factory != null) {       return widget.child;     }      return RawGestureDetector(       behavior: HitTestBehavior.opaque,       gestures: {         _DragGestureDetector:             GestureRecognizerFactoryWithHandlers<_DragGestureDetector>(           () => _DragGestureDetector(             onHorizontalDragDown: _handleHorizontalDragDown,             onHorizontalDragUpdate: _handleHorizontalDragUpdate,             onHorizontalDragUp: _handleHorizontalDragUp,           ),           (_) {},         ),       },       child: widget.child,     );   }    /// Getter for [FreeStyleSettings] from `widget.controller.value` to make code more readable.   FreeStyleSettings get settings =>       PainterController.of(context).value.settings.freeStyle;    /// Getter for [ShapeSettings] from `widget.controller.value` to make code more readable.   ShapeSettings get shapeSettings =>       PainterController.of(context).value.settings.shape;    /// Callback when the user holds their pointer(s) down onto the widget.   void _handleHorizontalDragDown(Offset globalPosition) {     // If the user is already drawing, don't create a new drawing     if (this.drawable != null) return;      // Create a new free-style drawable representing the current drawing     final PathDrawable drawable;     if (settings.mode == FreeStyleMode.draw) {       drawable = FreeStyleDrawable(         path: [_globalToLocal(globalPosition)],         color: settings.color,         strokeWidth: settings.strokeWidth,       );        // Add the drawable to the controller's drawables       PainterController.of(context).addDrawables([drawable]);     } else if (settings.mode == FreeStyleMode.erase) {       drawable = EraseDrawable(         path: [_globalToLocal(globalPosition)],         strokeWidth: settings.strokeWidth,       );       PainterController.of(context).groupDrawables();        // Add the drawable to the controller's drawables       PainterController.of(context).addDrawables([drawable], newAction: false);     } else {       return;     }      // Set the drawable as the current drawable     this.drawable = drawable;   }    /// Callback when the user moves, rotates or scales the pointer(s).   void _handleHorizontalDragUpdate(Offset globalPosition) {     final drawable = this.drawable;     // If there is no current drawable, ignore user input     if (drawable == null) return;      // Add the new point to a copy of the current drawable     final newDrawable = drawable.copyWith(       path: List<Offset>.from(drawable.path)         ..add(_globalToLocal(globalPosition)),     );     // Replace the current drawable with the copy with the added point     PainterController.of(context)         .replaceDrawable(drawable, newDrawable, newAction: false);     // Update the current drawable to be the new copy     this.drawable = newDrawable;   }    /// Callback when the user removes all pointers from the widget.   void _handleHorizontalDragUp() {     DrawableCreatedNotification(drawable).dispatch(context);      /// Reset the current drawable for the user to draw a new one next time     drawable = null;   }    Offset _globalToLocal(Offset globalPosition) {     final getBox = context.findRenderObject() as RenderBox;      return getBox.globalToLocal(globalPosition);   } } /// A custom recognizer that recognize at most only one gesture sequence.#6149#class _DragGestureDetector extends OneSequenceGestureRecognizer {   _DragGestureDetector({     required this.onHorizontalDragDown,     required this.onHorizontalDragUpdate,     required this.onHorizontalDragUp,   });    final ValueSetter<Offset> onHorizontalDragDown;   final ValueSetter<Offset> onHorizontalDragUpdate;   final VoidCallback onHorizontalDragUp;    bool _isTrackingGesture = false;    @override   void addPointer(PointerEvent event) {     if (!_isTrackingGesture) {       resolve(GestureDisposition.accepted);       startTrackingPointer(event.pointer);       _isTrackingGesture = true;     } else {       stopTrackingPointer(event.pointer);     }   }    @override   void handleEvent(PointerEvent event) {     if (event is PointerDownEvent) {       onHorizontalDragDown(event.position);     } else if (event is PointerMoveEvent) {       onHorizontalDragUpdate(event.position);     } else if (event is PointerUpEvent) {       onHorizontalDragUp();       stopTrackingPointer(event.pointer);       _isTrackingGesture = false;     }   }    @override   String get debugDescription => '_DragGestureDetector';    @override   void didStopTrackingLastPointer(int pointer) {} }
/// Flutter widget to move, scale and rotate [ObjectDrawable]s.#6149#class _ObjectWidget extends StatefulWidget {   /// Child widget.   final Widget child;    /// Whether scaling is enabled or not.   ///   /// If `false`, objects won't be movable, scalable or rotatable.   final bool interactionEnabled;    /// Creates a [_ObjectWidget] with the given [controller], [child] widget.   const _ObjectWidget({     Key? key,     required this.child,     this.interactionEnabled = true,   }) : super(key: key);    @override   _ObjectWidgetState createState() => _ObjectWidgetState(); } /// The control box container (only the UI, no logic).#6149#class _ObjectControlBox extends StatelessWidget {   /// Shape of the control box.   final BoxShape shape;    /// Whether the box is being used or not.   final bool active;    /// Color of control when it is not active.   /// Defaults to [Colors.white].   final Color inactiveColor;    /// Color of control when it is active.   /// If null is provided, the theme's accent color is used. If there is no theme, [Colors.blue] is used.   final Color? activeColor;    /// Color of the shadow surrounding the control.   /// Defaults to [Colors.black].   final Color shadowColor;    /// Creates an [_ObjectControlBox] with the given [shape] and [active].   ///   /// By default, it will be a [BoxShape.rectangle] shape and not active.   const _ObjectControlBox({     Key? key,     this.shape = BoxShape.rectangle,     this.active = false,     this.inactiveColor = Colors.white,     this.activeColor,     this.shadowColor = Colors.black,   }) : super(key: key);    @override   Widget build(BuildContext context) {     ThemeData? theme = Theme.of(context);     if (theme == ThemeData.fallback()) theme = null;     final activeColor = this.activeColor ?? theme?.accentColor ?? Colors.blue;     return AnimatedContainer(       duration: _ObjectWidgetState.controlsTransitionDuration,       decoration: BoxDecoration(         color: active ? activeColor : inactiveColor,         shape: shape,         boxShadow: [           BoxShadow(             color: shadowColor,             blurRadius: 2,           )         ],       ),     );   } }
/// Flutter widget to draw shapes.#6149#class _ShapeWidget extends StatefulWidget {   /// Child widget.   final Widget child;    /// Creates a [_ShapeWidget] with the given [controller], [child] widget.   const _ShapeWidget({     Key? key,     required this.child,   }) : super(key: key);    @override   _ShapeWidgetState createState() => _ShapeWidgetState(); }
/// Flutter widget to detect user input and request drawing [FreeStyleDrawable]s.#6149#class _TextWidget extends StatefulWidget {   /// Child widget.   final Widget child;    /// Creates a [_TextWidget] with the given [controller] and [child] widget.   const _TextWidget({     Key? key,     required this.child,   }) : super(key: key);    @override   _TextWidgetState createState() => _TextWidgetState(); } /// A dialog-like widget to edit text drawables in.#6149#class EditTextWidget extends StatefulWidget {   /// The controller for the current [FlutterPainter].   final PainterController controller;    /// The text drawable currently being edited.   final TextDrawable drawable;    /// If the text drawable being edited is new or not.   /// If it is new, the update action is not marked as a new action, so it is merged with   /// the previous action.   final bool isNew;    const EditTextWidget({     Key? key,     required this.controller,     required this.drawable,     this.isNew = false,   }) : super(key: key);    @override   EditTextWidgetState createState() => EditTextWidgetState(); }
/// Simple wrapper for testing specific widget /// so that we don't need to write things multiple times#6149#class WidgetTestbed {    /// In case that we want to specify platform  for running tests   Future<void> withPlatform(     final TargetPlatform platform,     final Function body,   ) async {     debugDefaultTargetPlatformOverride = platform;      try {       await body();     } finally {       debugDefaultTargetPlatformOverride = null;     }   }    Widget simpleWrap({     final Widget? child,     final Brightness brightness = Brightness.light,   }) {     return MaterialApp(       theme: ThemeData(brightness: brightness),       home: child != null ? Material(child: child) : null,     );   }    void increaseScreenSize(     final WidgetTester tester, [     final Size size = const Size(30000, 30000),   ]) {     tester.binding.window.physicalSizeTestValue = size;   }    void clearPhysicalSize(final WidgetTester tester) {     tester.binding.window.clearPhysicalSizeTestValue();   } }
/// ignore_for_file: prefer_const_constructors#6149#import 'package:flutter/material.dart';
/// A delegate that controls the parallax effect of a [Parallax] widget. /// /// Used by [ParallaxSingleChildLayout] (in the widgets folder) and /// [RenderParallaxSingleChildLayoutBox] (in this file). /// /// When asked to layout, [RenderParallaxSingleChildLayoutBox] first calls [getSize] with /// its incoming constraints to determine its size. It then calls /// [getConstraintsForChild] to determine the constraints to apply to the child. /// After the child completes its layout, [RenderParallaxSingleChildLayoutBox] /// calls [getPositionForChild] to determine the child's position. /// /// The [shouldRelayout] method is called when a new instance of the class /// is provided, to check if the new instance actually represents different /// information. /// /// See also: /// ///  * [ParallaxSingleChildLayout], the widget that uses this delegate. ///  * [RenderParallaxSingleChildLayoutBox], render object that uses this ///    delegate.#6149#abstract class ParallaxDelegate {   /// Creates a parallax layout delegate.   ///   /// The layout will update whenever [controller] notifies its listeners.   const ParallaxDelegate({     @required this.controller,   }) : assert(controller != null);    /// The controller used to update the parallax offset.   final ScrollController controller;    /// The size of this object given the incoming constraints.   ///   /// Defaults to the biggest size that satisfies the given constraints.   Size getSize(BoxConstraints constraints) => constraints.biggest;    /// The constraints for the child given the incoming constraints.   ///   /// During layout, the child is given the layout constraints returned by this   /// function. The child is required to pick a size for itself that satisfies   /// these constraints.   ///   /// Defaults to the given constraints.   BoxConstraints getConstraintsForChild(BoxConstraints constraints) =>       constraints;    /// The position where the child should be placed.   ///   /// The `size` argument is the size of the parent, which might be different   /// from the value returned by [getSize] if that size doesn't satisfy the   /// constraints passed to [getSize]. The `childSize` argument is the size of   /// the child, which will satisfy the constraints returned by   /// [getConstraintsForChild].   ///   /// Defaults to positioning the child in the upper left corner of the parent.   Offset getPositionForChild(Size size, Size childSize, RenderBox renderBox) =>       Offset.zero;    /// Called whenever a new instance of the custom layout delegate class is   /// provided to the [RenderParallaxSingleChildLayoutBox] object, or any time   /// that a new [ParallaxSingleChildLayout] object is created with a new instance   /// of the custom layout delegate class (which amounts to the same thing,   /// because the latter is implemented in terms of the former).   ///   /// If the new instance represents different information than the old   /// instance, then the method should return true, otherwise it should return   /// false.   ///   /// If the method returns false, then the [getSize],   /// [getConstraintsForChild], and [getPositionForChild] calls might be   /// optimized away.   ///   /// It's possible that the layout methods will get called even if   /// [shouldRelayout] returns false (e.g. if an ancestor changed its layout).   /// It's also possible that the layout method will get called   /// without [shouldRelayout] being called at all (e.g. if the parent changes   /// size).   bool shouldRelayout(covariant ParallaxDelegate oldDelegate) {     return controller != oldDelegate.controller;   } } /// A parallax layout delegate that follows a given direction when scrolled. /// /// See also: /// ///  * [ParallaxInsideDelegate], which is a delegate for widgets inside a scroll view. ///  * [ParallaxOutsideDelegate], which is a delegate for widgets outside a scroll view.#6149#abstract class ParallaxWithAxisDirectionDelegate extends ParallaxDelegate {   /// Creates a parallax layout delegate that indicates its own scroll direction   /// independently of the [controller.position] one.   ///   /// The [controller] and [flipDirection] arguments must not be null.   const ParallaxWithAxisDirectionDelegate({     @required ScrollController controller,     this.direction,     this.flipDirection = false,   })  : assert(controller != null),         assert(flipDirection != null),         super(controller: controller);    /// The direction of the parallax effect when scroll offset increases.   ///   /// When null, the direction is the same as the [controller].   final AxisDirection direction;    /// Whether to flip the given [direction].   ///   /// Defaults to false.   final bool flipDirection;    static Offset _getOffsetUnit(AxisDirection direction) {     switch (direction) {       case AxisDirection.up:       case AxisDirection.down:         return const Offset(0.0, 1.0);       case AxisDirection.left:       case AxisDirection.right:         return const Offset(1.0, 0.0);     }     return null;   }    @override   bool shouldRelayout(ParallaxWithAxisDirectionDelegate oldDelegate) {     return super.shouldRelayout(oldDelegate) ||         direction != oldDelegate.direction;   }    @override   Offset getPositionForChild(Size size, Size childSize, RenderBox renderBox) {     final ScrollPosition position = controller.position;     assert(position != null);      final AxisDirection parallaxDirection = _getParallaxDirection();     final Axis parallaxAxis = axisDirectionToAxis(parallaxDirection);      final Offset offsetUnit = _getOffsetUnit(parallaxDirection);      final double childExtent =         (parallaxAxis == Axis.horizontal) ? childSize.width : childSize.height;     final double mainAxisExtent =         (parallaxAxis == Axis.horizontal) ? size.width : size.height;      if (mainAxisExtent < childExtent) {       double scrollRatio =           getChildScrollRatio(offsetUnit, childExtent, renderBox);       if (parallaxDirection == AxisDirection.down ||           parallaxDirection == AxisDirection.right) {         scrollRatio = 1.0 - scrollRatio;       }        final offset =           childExtent - lerpDouble(mainAxisExtent, childExtent, scrollRatio);        return -(offsetUnit * offset);     } else {       return Offset.zero;     }   }    double getChildScrollRatio(       Offset offsetUnit, double childExtent, RenderBox renderBox);    AxisDirection _getParallaxDirection() {     AxisDirection parallaxDirection =         direction ?? controller?.position?.axisDirection;     if (flipDirection) {       parallaxDirection = flipAxisDirection(parallaxDirection);     }     assert(parallaxDirection != null);     return parallaxDirection;   } } /// A parallax delegate for a widget inside a scroll view. /// /// The parallax offset is determined by the position of the widget within its first [Scrollable] /// parent.#6149#class ParallaxInsideDelegate extends ParallaxWithAxisDirectionDelegate {   /// Creates a parallax layout delegate for widgets inside a scroll view.   ///   /// The [controller], [mainAxisExtent] and [flipDirection] arguments must not be null.   /// The [mainAxisExtent] argument must be positive.   const ParallaxInsideDelegate({     @required ScrollController controller,     @required this.mainAxisExtent,     AxisDirection direction,     bool flipDirection = false,   })  : assert(mainAxisExtent != null && mainAxisExtent >= 0.0),         super(           controller: controller,           direction: direction,           flipDirection: flipDirection,         );    /// The extent of the layout in the same axis as the scrolling.   final double mainAxisExtent;    @override   BoxConstraints getConstraintsForChild(BoxConstraints constraints) {     final AxisDirection parallaxDirection = _getParallaxDirection();     final Axis parallaxAxis = axisDirectionToAxis(parallaxDirection);     final Axis scrollAxis = controller?.position?.axis;      if (scrollAxis == parallaxAxis) {       return scrollAxis == Axis.horizontal           ? constraints.heightConstraints()           : constraints.widthConstraints();     } else {       return scrollAxis == Axis.horizontal           ? constraints.widthConstraints().tighten(width: mainAxisExtent)           : constraints.heightConstraints().tighten(height: mainAxisExtent);     }   }    @override   Size getSize(BoxConstraints constraints) {     final ScrollPosition position = controller.position;     assert(position != null);     final bool isHorizontalAxis = (position.axis == Axis.horizontal);      return constraints.constrain(new Size(         isHorizontalAxis ? mainAxisExtent : constraints.maxWidth,         isHorizontalAxis ? constraints.maxHeight : mainAxisExtent));   }    @override   double getChildScrollRatio(       Offset offsetUnit, double childExtent, RenderBox renderBox) {     final RenderAbstractViewport viewport =         RenderAbstractViewport.of(renderBox);     assert(viewport != null);      final ScrollPosition position = controller.position;     assert(position != null);     final bool isHorizontalAxis = (position.axis == Axis.horizontal);      final Offset localPositionOffset = isHorizontalAxis         ? new Offset(mainAxisExtent, 0.0)         : new Offset(0.0, mainAxisExtent); //offsetUnit * mainAxisExtent;     final Offset positionInViewport =         renderBox.localToGlobal(localPositionOffset, ancestor: viewport);      // One dimension should be 0.0, so this should be ok.     final double distanceFromLeading =         math.max(positionInViewport.dx, positionInViewport.dy);      double scrollRatio = distanceFromLeading /         (controller.position.viewportDimension + mainAxisExtent);     return scrollRatio;   } } /// A parallax delegate for a widget outside a scroll view, or for a widget where the parallax offset does /// not depend on its position within its first [Scrollable] parent.#6149#class ParallaxOutsideDelegate extends ParallaxWithAxisDirectionDelegate {   /// Creates a delegate for a widget outside a scroll view.   ///   /// The [controller] and [flipDirection] arguments must not be null.   const ParallaxOutsideDelegate({     @required ScrollController controller,     AxisDirection direction,     bool flipDirection = false,   }) : super(           controller: controller,           direction: direction,           flipDirection: flipDirection,         );    @override   BoxConstraints getConstraintsForChild(BoxConstraints constraints) {     final AxisDirection parallaxDirection = _getParallaxDirection();     final Axis parallaxAxis = axisDirectionToAxis(parallaxDirection);      return parallaxAxis == Axis.horizontal         ? constraints.heightConstraints()         : constraints.widthConstraints();   }    @override   double getChildScrollRatio(       Offset offsetUnit, double childExtent, RenderBox renderBox) {     double scrollRatio = 0.0;     final ScrollPosition position = controller.position;     final double offset = controller.offset;     final double minScrollExtent =         position?.minScrollExtent ?? double.negativeInfinity;     final double maxScrollExtent = position?.maxScrollExtent ?? double.infinity;      if (minScrollExtent.isFinite && maxScrollExtent.isFinite) {       scrollRatio =           (offset - minScrollExtent) / (maxScrollExtent - minScrollExtent);     }     return scrollRatio;   } } /// Defers the parallax layout of its single child to a delegate. /// /// The delegate can determine the layout constraints for the child and can /// decide where to position the child. The delegate can also determine the size /// of the parent, but the size of the parent cannot depend on the size of the /// child.#6149#class RenderParallaxSingleChildLayoutBox extends RenderShiftedBox {   /// Creates a render box that defers its parallax layout to a delegate.   ///   /// The [delegate] argument must not be null.   RenderParallaxSingleChildLayoutBox({     RenderBox child,     @required ParallaxDelegate delegate,   })  : assert(delegate != null),         _delegate = delegate,         super(child);    /// A delegate that controls this object's layout.   ParallaxDelegate get delegate => _delegate;   ParallaxDelegate _delegate;   set delegate(ParallaxDelegate newDelegate) {     assert(newDelegate != null);     if (_delegate == newDelegate) {       return;     }     final ParallaxDelegate oldDelegate = _delegate;     if (newDelegate.runtimeType != oldDelegate.runtimeType ||         newDelegate.shouldRelayout(oldDelegate)) {       markNeedsLayout();     }     _delegate = newDelegate;     if (attached) {       oldDelegate?.controller?.removeListener(markNeedsLayout);       newDelegate?.controller?.addListener(markNeedsLayout);     }   }    @override   void attach(PipelineOwner owner) {     super.attach(owner);     _delegate?.controller?.addListener(markNeedsLayout);   }    @override   void detach() {     _delegate?.controller?.removeListener(markNeedsLayout);     super.detach();   }    Size _getSize(BoxConstraints constraints) {     return constraints.constrain(_delegate.getSize(constraints));   }    @override   void performLayout() {     size = _getSize(constraints);     if (child != null) {       final BoxConstraints childConstraints =           delegate.getConstraintsForChild(constraints);       assert(childConstraints.debugAssertIsValid(isAppliedConstraint: true));       child.layout(childConstraints, parentUsesSize: !childConstraints.isTight);       final BoxParentData childParentData = child.parentData;       childParentData.offset = delegate.getPositionForChild(           size,           childConstraints.isTight ? childConstraints.smallest : child.size,           this);     }   } }
/// A widget that applies a parallax effect on its child. /// /// There are three options for constructing a [Parallax]: /// ///   1. The [Parallax.inside], that computes the parallax offset from its position ///   in its first [Scrollable] parent. ///   Useful for list or grid items. /// ///   2. The [Parallax.outside], that computes the parallax offset from the percentage ///   of the scrollable's container extent. ///   Useful for a list or grid background. /// ///   3. The [Parallax.custom] takes a [ParallaxDelegate], which provides the ability ///   to customize additional aspects of the child model. For example, a [ParallaxDelegate] ///   can control the algorithm used to computes the parallax offset of the child within its parent. /// /// See also: /// ///  * [ParallaxSingleChildLayout], which uses a delegate to control the parallax layout of ///    a single child.#6149#class Parallax extends StatelessWidget {   /// Creates a parallax widget for a widget inside a scroll view.   ///   /// The [mainAxisExtent] and [flipDirection] arguments must not be null.   /// The [mainAxisExtent] argument must be positive.   const Parallax.inside({     Key key,     @required this.child,     @required this.mainAxisExtent,     this.direction,     this.flipDirection = false,   })  : assert(mainAxisExtent != null && mainAxisExtent >= 0.0),         delegate = null,         super(key: key);    /// Creates a parallax widget for a widget outside a scroll view.   ///   /// The [controller] and [flipDirection] arguments must not be null.   Parallax.outside({     Key key,     @required this.child,     @required ScrollController controller,     this.direction,     this.flipDirection = false,   })  : assert(controller != null),         mainAxisExtent = null,         delegate = new ParallaxOutsideDelegate(             controller: controller,             direction: direction,             flipDirection: flipDirection),         super(key: key);    /// Creates a parallax widget with a custom parallax layout.   ///   /// The [delegate] argument must not be null.   const Parallax.custom({     Key key,     @required this.child,     @required this.delegate,   })  : assert(delegate != null),         mainAxisExtent = null,         direction = null,         flipDirection = null,         super(key: key);    /// The child of this widget.   final Widget child;    /// The delegate that controls the algorithm used to position the child within its parent.   final ParallaxDelegate delegate;    /// The extent of the child in the same axis as the scrolling.   final double mainAxisExtent;    /// The direction of the parallax effect when scroll offset increases.   ///   /// When null, the direction is the same as the [controller].   final AxisDirection direction;    /// Whether to flip the given [direction].   ///   /// Defaults to false.   final bool flipDirection;    @override   Widget build(BuildContext context) {     ParallaxDelegate parallaxDelegate = delegate;     if (parallaxDelegate == null) {       final ScrollPosition position = Scrollable.of(context).position;       final ScrollController controller = new ScrollController();       controller.attach(position);       parallaxDelegate = new ParallaxInsideDelegate(         mainAxisExtent: mainAxisExtent,         direction: direction,         controller: controller,         flipDirection: flipDirection,       );     }      return new ClipRect(       child: new ParallaxSingleChildLayout(         delegate: parallaxDelegate,         child: child,       ),     );   } } /// A widget that defers the parallax layout of its single child to a delegate. /// /// The delegate can determine the layout constraints for the child and can /// decide where to position the child. The delegate can also determine the size /// of the parent, but the size of the parent cannot depend on the size of the /// child. /// /// See also: /// ///  * [ParallaxDelegate], which controls the parallax layout of the child.#6149#class ParallaxSingleChildLayout extends SingleChildRenderObjectWidget {   /// Creates a custom single child layout.   ///   /// The [delegate] argument must not be null.   const ParallaxSingleChildLayout({     Key key,     @required this.delegate,     Widget child,   })  : assert(delegate != null),         super(key: key, child: child);    /// The delegate that controls the layout of the child.   final ParallaxDelegate delegate;    @override   RenderParallaxSingleChildLayoutBox createRenderObject(BuildContext context) {     return new RenderParallaxSingleChildLayoutBox(delegate: delegate);   }    @override   void updateRenderObject(       BuildContext context, RenderParallaxSingleChildLayoutBox renderObject) {     renderObject.delegate = delegate;   } }
/// ignore: public_member_api_docs#6149#void registerPlugins(Registrar registrar) {   UrlLauncherPlugin.registerWith(registrar);   registrar.registerMessageHandler(); }
/// Email Regex - A predefined type for handling email matching#6149#const emailPattern = r"\b[\w\.-]+@[\w\.-]+\.\w{2,4}\b"; /// URL Regex - A predefined type for handling URL matching#6149#const urlPattern = /// Phone Regex - A predefined type for handling phone matching#6149#const phonePattern =
/// A MatchText class which provides a structure for [ParsedText] to handle /// Pattern matching and also to provide custom [Function] and custom [TextStyle].#6149#class MatchText {   /// Used to enforce Predefined regex to match from   ParsedType type;    /// If no [type] property is explicitly defined then this propery must be   /// non null takes a [regex] string   String? pattern;    /// Takes a custom style of [TextStyle] for the matched text widget   TextStyle? style;    /// A custom [Function] to handle onTap.   Function(String)? onTap;    /// A callback function that takes two parameter String & pattern   ///   /// @param str - is the word that is being matched   /// @param pattern - pattern passed to the MatchText class   ///   /// eg: Your str is 'Mention [@michel:5455345]' where 5455345 is ID of this user   /// and @michel the value to display on interface.   /// Your pattern for ID & username extraction : `/\[(@[^:]+):([^\]]+)\]/`i   /// Displayed text will be : Mention `@michel`   Map<String, String> Function({     required String str,     required String pattern,   })? renderText;    /// A callback function that takes the [text] the matches the [pattern] and returns   /// the [Widget] to be displayed inside a [WidgetSpan]   Widget Function({     required String text,     required String pattern,   })? renderWidget;    /// Creates a MatchText object   MatchText({     this.type = ParsedType.CUSTOM,     this.pattern,     this.style,     this.onTap,     this.renderText,     this.renderWidget,   }); }
/// Parse text and make them into multiple Flutter Text widgets#6149#class ParsedText extends StatelessWidget {   /// If non-null, the style to use for the global text.   ///   /// It takes a [TextStyle] object as it's property to style all the non links text objects.   final TextStyle? style;    /// Takes a list of [MatchText] object.   ///   /// This list is used to find patterns in the String and assign onTap [Function] when its   /// tapped and also to provide custom styling to the linkify text   final List<MatchText> parse;    /// Text that is rendered   ///   /// Takes a [String]   final String text;    /// A text alignment property used to align the the text enclosed   ///   /// Uses a [TextAlign] object and default value is [TextAlign.start]   final TextAlign alignment;    /// A text alignment property used to align the the text enclosed   ///   /// Uses a [TextDirection] object and default value is [TextDirection.start]   final TextDirection? textDirection;    /// Whether the text should break at soft line breaks.   ///   ///If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.   final bool softWrap;    /// How visual overflow should be handled.   final TextOverflow overflow;    /// The number of font pixels for each logical pixel.   ///   /// For example, if the text scale factor is 1.5, text will be 50% larger than   /// the specified font size.   final double textScaleFactor;    /// An optional maximum number of lines for the text to span, wrapping if necessary.   /// If the text exceeds the given number of lines, it will be truncated according   /// to [overflow].   ///   /// If this is 1, text will not wrap. Otherwise, text will be wrapped at the   /// edge of the box.   final int? maxLines;    /// {@macro flutter.painting.textPainter.strutStyle}   final StrutStyle? strutStyle;    /// {@macro flutter.widgets.text.DefaultTextStyle.textWidthBasis}   final TextWidthBasis textWidthBasis;    /// Make this text selectable.   ///   /// SelectableText does not support softwrap, overflow, textScaleFactor   final bool selectable;    /// onTap function for the whole widget   final Function? onTap;    /// Global regex options for the whole string,   ///   /// Note: Removed support for regexOptions for MatchText and now it uses global regex options.   final RegexOptions regexOptions;    /// Creates a parsedText widget   ///   /// [text] paramtere should not be null and is always required.   /// If the [style] argument is null, the text will use the style from the   /// closest enclosing [DefaultTextStyle].   ParsedText({     Key? key,     required this.text,     this.parse = const <MatchText>[],     this.style,     this.alignment = TextAlign.start,     this.textDirection,     this.softWrap = true,     this.overflow = TextOverflow.clip,     this.textScaleFactor = 1.0,     this.strutStyle,     this.textWidthBasis = TextWidthBasis.parent,     this.maxLines,     this.onTap,     this.selectable = false,     this.regexOptions = const RegexOptions(),   }) : super(key: key);    @override   Widget build(BuildContext context) {     // Seperate each word and create a new Array     String newString = text;      Map<String, MatchText> _mapping = Map<String, MatchText>();      parse.forEach((e) {       if (e.type == ParsedType.EMAIL) {         _mapping[emailPattern] = e;       } else if (e.type == ParsedType.PHONE) {         _mapping[phonePattern] = e;       } else if (e.type == ParsedType.URL) {         _mapping[urlPattern] = e;       } else {         _mapping[e.pattern!] = e;       }     });      final pattern = '(${_mapping.keys.toList().join('|')})';      List<InlineSpan> widgets = [];      newString.splitMapJoin(       RegExp(         pattern,         multiLine: regexOptions.multiLine,         caseSensitive: regexOptions.caseSensitive,         dotAll: regexOptions.dotAll,         unicode: regexOptions.unicode,       ),       onMatch: (Match match) {         final matchText = match[0];          final mapping = _mapping[matchText!] ??             _mapping[_mapping.keys.firstWhere((element) {               final reg = RegExp(                 element,                 multiLine: regexOptions.multiLine,                 caseSensitive: regexOptions.caseSensitive,                 dotAll: regexOptions.dotAll,                 unicode: regexOptions.unicode,               );               return reg.hasMatch(matchText);             }, orElse: () {               return '';             })];          InlineSpan widget;          if (mapping != null) {           if (mapping.renderText != null) {             Map<String, String> result =                 mapping.renderText!(str: matchText, pattern: pattern);              widget = TextSpan(               text: "${result['display']}",               style: mapping.style != null ? mapping.style : style,               recognizer: TapGestureRecognizer()                 ..onTap = () {                   final value = result['value'] ?? matchText;                   mapping.onTap?.call(value);                 },             );           } else if (mapping.renderWidget != null) {             widget = WidgetSpan(               alignment: PlaceholderAlignment.middle,               child: GestureDetector(                 onTap: () => mapping.onTap!(matchText),                 child: mapping.renderWidget!(                     text: matchText, pattern: mapping.pattern!),               ),             );           } else {             widget = TextSpan(               text: "$matchText",               style: mapping.style != null ? mapping.style : style,               recognizer: TapGestureRecognizer()                 ..onTap = () => mapping.onTap!(matchText),             );           }         } else {           widget = TextSpan(             text: "$matchText",             style: this.style,           );         }          widgets.add(widget);          return '';       },       onNonMatch: (String text) {         widgets.add(TextSpan(           text: "$text",           style: this.style,         ));          return '';       },     );      if (selectable) {       return SelectableText.rich(         TextSpan(children: <InlineSpan>[...widgets], style: style),         maxLines: maxLines,         strutStyle: strutStyle,         textWidthBasis: textWidthBasis,         textAlign: alignment,         textDirection: textDirection,         onTap: onTap as void Function()?,       );     }      return RichText(       softWrap: softWrap,       overflow: overflow,       textScaleFactor: textScaleFactor,       maxLines: maxLines,       strutStyle: strutStyle,       textWidthBasis: textWidthBasis,       textAlign: alignment,       textDirection: textDirection,       text: TextSpan(         text: '',         children: <InlineSpan>[...widgets],         style: style,       ),     );   } }
/// RegexOptions#6149#class RegexOptions {   /// Creates a RegexOptions object   /// If `multiLine` is enabled, then `^` and `$` will match the beginning and   ///  end of a _line_, in addition to matching beginning and end of input,   ///  respectively.   ///   ///  If `caseSensitive` is disabled, then case is ignored.   ///   ///  If `unicode` is enabled, then the pattern is treated as a Unicode   ///  pattern as described by the ECMAScript standard.   ///   ///  If `dotAll` is enabled, then the `.` pattern will match _all_ characters,   ///  including line terminators.   const RegexOptions({     this.multiLine = false,     this.caseSensitive = true,     this.unicode = false,     this.dotAll = false,   });    final bool multiLine;   final bool unicode;   final bool caseSensitive;   final bool dotAll; }
///   static const Node wallNode = Node( //     nodeWidget: WallNodePaintWidget(unitSize, i, j, callback, removeNode) //   ); // } // class Node{ //   const Node({this.nodeWidget,this.type,this.staticRect}); //   final Widget nodeWidget; //   final int type; //   final Rect staticRect; // }#6149#enum GridGenerationFunction{   random,   backtracker,   recursive, }
/// ImageNodes#6149#class NodeImageWidget extends StatefulWidget {    final double boxSize;   final String asset;   // final Function(Image img) callback;   NodeImageWidget(this.boxSize, this.asset,); //this.callback);   @override   _NodeImageWidgetState createState() => _NodeImageWidgetState(); }
/// Creates a new path that is drawn from the segments of `source`. /// /// Dash intervals are controled by the `dashArray` - see [CircularIntervalList] /// for examples. /// /// `dashOffset` specifies an initial starting point for the dashing. /// /// Passing a `source` that is an empty path will return an empty path.#6149#Path dashPath( /// Specifies the starting position of a dash array on a path, either as a /// percentage or absolute value. /// /// The internal value will be guaranteed to not be null.#6149#class DashOffset {   /// Create a DashOffset that will be measured as a percentage of the length   /// of the segment being dashed.   ///   /// `percentage` will be clamped between 0.0 and 1.0.   DashOffset.percentage(double percentage)       : _rawVal = percentage.clamp(0.0, 1.0),         _dashOffsetType = _DashOffsetType.Percentage;    /// Create a DashOffset that will be measured in terms of absolute pixels   /// along the length of a [Path] segment.   const DashOffset.absolute(double start)       : _rawVal = start,         _dashOffsetType = _DashOffsetType.Absolute;    final double _rawVal;   final _DashOffsetType _dashOffsetType;    double _calculate(double length) {     return _dashOffsetType == _DashOffsetType.Absolute         ? _rawVal         : length * _rawVal;   }    @override   bool operator ==(Object other) {     if (identical(this, other)) {       return true;     }      return other is DashOffset &&         other._rawVal == _rawVal &&         other._dashOffsetType == _dashOffsetType;   }    @override   int get hashCode => Object.hash(_rawVal, _dashOffsetType); } /// A circular array of dash offsets and lengths. /// /// For example, the array `[5, 10]` would result in dashes 5 pixels long /// followed by blank spaces 10 pixels long.  The array `[5, 10, 5]` would /// result in a 5 pixel dash, a 10 pixel gap, a 5 pixel dash, a 5 pixel gap, /// a 10 pixel dash, etc. /// /// Note that this does not quite conform to an [Iterable<T>], because it does /// not have a moveNext.#6149#class CircularIntervalList<T> {   CircularIntervalList(this._vals);    final List<T> _vals;   int _idx = 0;    T get next {     if (_idx >= _vals.length) {       _idx = 0;     }     return _vals[_idx++];   } }
/// Creates a [Path] object from an SVG data string. /// /// Passing an empty string will result in an empty path.#6149#Path parseSvgPathData(String svg) {   if (svg == '') {     return Path();   }    final SvgPathStringSource parser = SvgPathStringSource(svg);   final FlutterPathProxy path = FlutterPathProxy();   final SvgPathNormalizer normalizer = SvgPathNormalizer();   for (PathSegmentData seg in parser.parseSegments()) {     normalizer.emitSegment(seg, path);   }   return path.path; } /// A [PathProxy] that takes the output of the path parsing library /// and maps it to a dart:ui [Path].#6149#class FlutterPathProxy extends PathProxy {   FlutterPathProxy({Path? p}) : path = p ?? Path();    final Path path;    @override   void close() {     path.close();   }    @override   void cubicTo(       double x1, double y1, double x2, double y2, double x3, double y3) {     path.cubicTo(x1, y1, x2, y2, x3, y3);   }    @override   void lineTo(double x, double y) {     path.lineTo(x, y);   }    @override   void moveTo(double x, double y) {     path.moveTo(x, y);   } }
/// The point on the path to trim from.#6149#enum PathTrimOrigin {   /// Specifies that trimming should start from the first point in a segment.   begin,    /// Specifies that trimming should start from the last point in a segment.   end } /// Trims `percentage` of the `source` [Path] away and returns a new path. /// /// The `percentage` parameter will be clamped between 0..1 and must not be null. /// /// Use the `firstOnly` parameter to specify whether this should apply only /// to the first segment of the path (and thus return only the first trimmed /// segment) or all segments of the path.  Multi-segment paths (i.e. paths with a /// move verb) will all be trimmed if this is false; otherwise, a trimmed version /// of only the first path segment will be returned. It must not be null. /// /// The `origin` parameter allows the user to control which end of the path will be /// trimmed.  It must not be null. /// /// If `source` is empty, an empty path will be returned.#6149#Path trimPath(
/// /// An implementation of [TextInputFormatter] provides a way to input date form /// with [TextField], such as dd/MM/yyyy. In order to guide user about input form, /// the formatter will provide [TextField] a placeholder --/--/---- as soon as /// user start editing. During editing session, the formatter will replace appropriate /// placeholder characters by user's input. ///#6149#class DateInputFormatter extends TextInputFormatter {   String _placeholder = '--/--/----';   TextEditingValue? _lastNewValue;    @override   TextEditingValue formatEditUpdate(       TextEditingValue oldValue, TextEditingValue newValue) {     /// provides placeholder text when user start editing     if (oldValue.text.isEmpty) {       oldValue = oldValue.copyWith(         text: _placeholder,       );       newValue = newValue.copyWith(         text: _fillInputToPlaceholder(newValue.text),       );       return newValue;     }      /// nothing changes, nothing to do     if (newValue == _lastNewValue) {       return oldValue;     }     _lastNewValue = newValue;      int offset = newValue.selection.baseOffset;      /// restrict user's input within the length of date form     if (offset > 10) {       return oldValue;     }      if (oldValue.text == newValue.text && oldValue.text.length > 0) {       return newValue;     }      final String oldText = oldValue.text;     final String newText = newValue.text;     String? resultText;      /// handle user editing, there're two cases:     /// 1. user add new digit: replace '-' at cursor's position by user's input.     /// 2. user delete digit: replace digit at cursor's position by '-'     int index = _indexOfDifference(newText, oldText);     if (oldText.length < newText.length) {       /// add new digit       String newChar = newText[index];       if (index == 2 || index == 5) {         index++;         offset++;       }       resultText = oldText.replaceRange(index, index + 1, newChar);       if (offset == 2 || offset == 5) {         offset++;       }     } else if (oldText.length > newText.length) {       /// delete digit       if (oldText[index] != '/') {         resultText = oldText.replaceRange(index, index + 1, '-');         if (offset == 3 || offset == 6) {           offset--;         }       } else {         resultText = oldText;       }     }      /// verify the number and position of splash character     final splashes = resultText!.replaceAll(RegExp(r'[^/]'), '');     int count = splashes.length;     if (resultText.length > 10 ||         count != 2 ||         resultText[2].toString() != '/' ||         resultText[5].toString() != '/') {       return oldValue;     }      return oldValue.copyWith(       text: resultText,       selection: TextSelection.collapsed(offset: offset),       composing: defaultTargetPlatform == TargetPlatform.iOS           ? TextRange(start: 0, end: 0)           : TextRange.empty,     );   }    int _indexOfDifference(String? cs1, String? cs2) {     if (cs1 == cs2) {       return INDEX_NOT_FOUND;     }     if (cs1 == null || cs2 == null) {       return 0;     }     int i;     for (i = 0; i < cs1.length && i < cs2.length; ++i) {       if (cs1[i] != cs2[i]) {         break;       }     }     if (i < cs2.length || i < cs1.length) {       return i;     }     return INDEX_NOT_FOUND;   }    String _fillInputToPlaceholder(String? input) {     if (input == null || input.isEmpty) {       return _placeholder;     }     String result = _placeholder;     final index = [0, 1, 3, 4, 6, 7, 8, 9];     final length = min(index.length, input.length);     for (int i = 0; i < length; i++) {       result = result.replaceRange(index[i], index[i] + 1, input[i]);     }     return result;   } }
/// /// An implementation of [NumberInputFormatter] automatically inserts thousands /// separators to numeric input. For example, a input of `1234` should be /// formatted to `1,234`. ///#6149#class ThousandsFormatter extends NumberInputFormatter {   static final NumberFormat _formatter = NumberFormat.decimalPattern();    final FilteringTextInputFormatter _decimalFormatter;   final String _decimalSeparator;   final RegExp _decimalRegex;    final NumberFormat? formatter;   final bool allowFraction;    ThousandsFormatter({this.formatter, this.allowFraction = false})       : _decimalSeparator = (formatter ?? _formatter).symbols.DECIMAL_SEP,         _decimalRegex = RegExp(allowFraction             ? '[0-9]+([${(formatter ?? _formatter).symbols.DECIMAL_SEP}])?'             : r'\d+'),         _decimalFormatter = FilteringTextInputFormatter.allow(RegExp(             allowFraction                 ? '[0-9]+([${(formatter ?? _formatter).symbols.DECIMAL_SEP}])?'                 : r'\d+'));    @override   String _formatPattern(String? digits) {     if (digits == null || digits.isEmpty) return '';     num number;     if (allowFraction) {       String decimalDigits = digits;       if (_decimalSeparator != '.') {         decimalDigits = digits.replaceFirst(RegExp(_decimalSeparator), '.');       }       number = double.tryParse(decimalDigits) ?? 0.0;     } else {       number = int.tryParse(digits) ?? 0;     }     final result = (formatter ?? _formatter).format(number);     if (allowFraction && digits.endsWith(_decimalSeparator)) {       return '$result$_decimalSeparator';     }     return result;   }    @override   TextEditingValue _formatValue(       TextEditingValue oldValue, TextEditingValue newValue) {     return _decimalFormatter.formatEditUpdate(oldValue, newValue);   }    @override   bool _isUserInput(String s) {     return s == _decimalSeparator || _decimalRegex.firstMatch(s) != null;   } } /// /// An implementation of [NumberInputFormatter] that converts a numeric input /// to credit card number form (4-digit grouping). For example, a input of /// `12345678` should be formatted to `1234 5678`. ///#6149#class CreditCardFormatter extends NumberInputFormatter {   static final RegExp _digitOnlyRegex = RegExp(r'\d+');   static final FilteringTextInputFormatter _digitOnlyFormatter =       FilteringTextInputFormatter.allow(_digitOnlyRegex);    final String separator;    CreditCardFormatter({this.separator = ' '});    @override   String _formatPattern(String digits) {     StringBuffer buffer = StringBuffer();     int offset = 0;     int count = min(4, digits.length);     final length = digits.length;     for (; count <= length; count += min(4, max(1, length - count))) {       buffer.write(digits.substring(offset, count));       if (count < length) {         buffer.write(separator);       }       offset = count;     }     return buffer.toString();   }    @override   TextEditingValue _formatValue(       TextEditingValue oldValue, TextEditingValue newValue) {     return _digitOnlyFormatter.formatEditUpdate(oldValue, newValue);   }    @override   bool _isUserInput(String s) {     return _digitOnlyRegex.firstMatch(s) != null;   } } /// /// An abstract class extends from [TextInputFormatter] and does numeric filter. /// It has an abstract method `_format()` that lets its children override it to /// format input displayed on [TextField] ///#6149#abstract class NumberInputFormatter extends TextInputFormatter {   TextEditingValue? _lastNewValue;    @override   TextEditingValue formatEditUpdate(       TextEditingValue oldValue, TextEditingValue newValue) {     /// nothing changes, nothing to do     if (newValue.text == _lastNewValue?.text) {       return newValue;     }     _lastNewValue = newValue;      /// remove all invalid characters     newValue = _formatValue(oldValue, newValue);      /// current selection     int selectionIndex = newValue.selection.end;      /// format original string, this step would add some separator     /// characters to original string     final newText = _formatPattern(newValue.text);      /// count number of inserted character in new string     int insertCount = 0;      /// count number of original input character in new string     int inputCount = 0;     for (int i = 0; i < newText.length && inputCount < selectionIndex; i++) {       final character = newText[i];       if (_isUserInput(character)) {         inputCount++;       } else {         insertCount++;       }     }      /// adjust selection according to number of inserted characters staying before     /// selection     selectionIndex += insertCount;     selectionIndex = min(selectionIndex, newText.length);      /// if selection is right after an inserted character, it should be moved     /// backward, this adjustment prevents an issue that user cannot delete     /// characters when cursor stands right after inserted characters     if (selectionIndex - 1 >= 0 &&         selectionIndex - 1 < newText.length &&         !_isUserInput(newText[selectionIndex - 1])) {       selectionIndex--;     }      return newValue.copyWith(         text: newText,         selection: TextSelection.collapsed(offset: selectionIndex),         composing: TextRange.empty);   }    /// check character from user input or being inserted by pattern formatter   bool _isUserInput(String s);    /// format user input with pattern formatter   String _formatPattern(String digits);    /// validate user input   TextEditingValue _formatValue(       TextEditingValue oldValue, TextEditingValue newValue); }
///          iconSize: 22.0,#6149#          onTap: (index) {             _curIndex = index;             setState(() { });           },
///              height: 42.0,#6149#                child: Row( //      height: 100.0,#6149#    margin: EdgeInsets.only(bottom: 16.0, left: 16.0, right: 16.0),
///      height: 400.0,#6149#      child: Column( //      color: Colors.yellow,#6149#      margin: EdgeInsets.all(16.0), //      height: 200.0,#6149#      child: Column( //      color: Colors.yellow,#6149#      margin: EdgeInsets.all(16.0), //      height: 200.0,#6149#      child: Column(
///      height: 400.0,#6149#      child: Column( //          GridView.builder( //            physics: ScrollPhysics(), //              shrinkWrap: true, //              itemCount: cards.length, //              gridDelegate: new SliverGridDelegateWithFixedCrossAxisCount( //                  crossAxisCount: 2), //              itemBuilder: (BuildContext context, int index) { //                return _getBankCard(index); //              }),#6149#          GridView.count(crossAxisCount: size.width > 320 ? 2 : 1,
///      color: Colors.yellow,#6149#      margin: EdgeInsets.all(16.0), //      height: 200.0,#6149#      child: Column(
///                      padding: EdgeInsets.all(16.0),#6149#                      margin: EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
///                        fontSize: 10.0,#6149#                          fontWeight: FontWeight.bold), //      height: 88.0, //      width: 150.0,#6149#      decoration: BoxDecoration(
/// To get started quickly, change this to your heroku deployment of // https://github.com/PaystackHQ/sample-charge-card-backend // Step 1. Visit https://github.com/PaystackHQ/sample-charge-card-backend // Step 2. Click "Deploy to heroku" // Step 3. Login with your heroku credentials or create a free heroku account // Step 4. Provide your secret key and an email with which to start all test transactions // Step 5. Replace {YOUR_BACKEND_URL} below with the url generated by heroku (format https://some-url.herokuapp.com)#6149#String backendUrl = '{YOUR_BACKEND_URL}'; // Set this to a public key that matches the secret key you supplied while creating the heroku instance#6149#String paystackPublicKey = '{YOUR_PAYSTACK_PUBLIC_KEY}';
/// Holds data that's different on Android and iOS#6149#class PlatformInfo {   final String userAgent;   final String paystackBuild;   final String deviceId;    static Future<PlatformInfo> fromMethodChannel(MethodChannel channel) async {     // TODO: Update for every new versions.     //  And there should a better way to fucking do this     final pluginVersion = "1.0.5";      final platform = Platform.operatingSystem;     String userAgent = "${platform}_Paystack_$pluginVersion";     String deviceId = await channel.invokeMethod('getDeviceId') ?? "";     return PlatformInfo._(       userAgent: userAgent,       paystackBuild: pluginVersion,       deviceId: deviceId,     );   }    const PlatformInfo._({     required String userAgent,     required String paystackBuild,     required String deviceId,   })   : userAgent = userAgent,         paystackBuild = paystackBuild,         deviceId = deviceId;    @override   String toString() {     return '[userAgent = $userAgent, paystackBuild = $paystackBuild, deviceId = $deviceId]';   } }
/// The class for the Payment Card model. Has utility methods for validating /// the card.#6149#class PaymentCard {   // List of supported card types   final List<CardType> cardTypes = [     _Visa(),     _MasterCard(),     _AmericanExpress(),     _DinersClub(),     _Discover(),     _Jcb(),     _Verve()   ];    /// Name on card   String? name;    /// Card number   String? _number;    /// Card CVV or CVC   String? _cvc;    /// Expiry month   int? expiryMonth = 0;    /// Expiry year   int? expiryYear = 0;    /// Bank Address line 1   String? addressLine1;    /// Bank Address line 2   String? addressLine2;    /// Bank Address line 3   String? addressLine3;    /// Bank Address line 4   String? addressLine4;    /// Postal code of the bank address   String? addressPostalCode;    /// Country of the bank   String? addressCountry;    String? country;    /// Type of card   String? _type;    String? _last4Digits;    set type(String? value) => _type = value;    String? get number => _number;    String? get last4Digits => _last4Digits;    String? get type {     // If type is empty and the number isn't empty     if (StringUtils.isEmpty(_type)) {       if (!StringUtils.isEmpty(number)) {         for (var cardType in cardTypes) {           if (cardType.hasFullMatch(number)) {             return cardType.toString();           }         }       }       return CardType.unknown;     }     return _type;   }    // Get the card type by matching the starting characters against the Issuer   // Identification Number (IIN)   String getTypeForIIN(String? cardNumber) {     // If type is empty and the number isn't empty     if (!StringUtils.isEmpty(cardNumber)) {       for (var cardType in cardTypes) {         if (cardType.hasStartingMatch(cardNumber)) {           return cardType.toString();         }       }       return CardType.unknown;     }     return CardType.unknown;   }    set number(String? value) {     _number = CardUtils.getCleanedNumber(value);     if (number!.length == 4) {       _last4Digits = number;     } else if (number!.length > 4) {       _last4Digits = number!.substring(number!.length - 4);     } else {       // whatever is appropriate in this case       _last4Digits = number;     }   }    nullifyNumber() {     _number = null;   }    String? get cvc => _cvc;    set cvc(String? value) {     _cvc = CardUtils.getCleanedNumber(value);   }    PaymentCard(       {required String? number,       required String? cvc,       required this.expiryMonth,       required this.expiryYear,       String? name,       String? addressLine1,       String? addressLine2,       String? addressLine3,       String? addressLine4,       String? addressPostCode,       String? addressCountry,       String? country}) {     this.number = number;     this.cvc = cvc;     this.name = StringUtils.nullify(name);     this.addressLine1 = StringUtils.nullify(addressLine1);     this.addressLine2 = StringUtils.nullify(addressLine2);     this.addressLine3 = StringUtils.nullify(addressLine3);     this.addressLine4 = StringUtils.nullify(addressLine4);     this.addressCountry = StringUtils.nullify(addressCountry);     this.addressPostalCode = StringUtils.nullify(addressPostalCode);      this.country = StringUtils.nullify(country);     this.type = type;   }    PaymentCard.empty() {     this.expiryYear = 0;     this.expiryMonth = 0;     this._number = null;     this.cvc = null;   }    /// Validates the CVC or CVV of the card   /// Returns true if the cvc is valid   bool isValid() {     return cvc != null &&         number != null &&         expiryMonth != null &&         expiryYear != null &&         validNumber(null) &&         CardUtils.isNotExpired(expiryYear, expiryMonth) &&         validCVC(null);   }    /// Validates the CVC or CVV of a card.   /// Returns true if CVC is valid and false otherwise   bool validCVC(String? cardCvc) {     cardCvc ??= this.cvc;      if (cardCvc == null || cardCvc.trim().isEmpty) return false;      var cvcValue = cardCvc.trim();     bool validLength =         ((_type == null && cvcValue.length >= 3 && cvcValue.length <= 4) ||             (CardType.americanExpress == _type && cvcValue.length == 4) ||             (CardType.americanExpress != _type && cvcValue.length == 3));     return (CardUtils.isWholeNumberPositive(cvcValue) && validLength);   }    /// Validates the number of the card   /// Returns true if the number is valid. Returns false otherwise   bool validNumber(String? cardNumber) {     if (cardNumber == null) {       cardNumber = this.number;     }     if (StringUtils.isEmpty(cardNumber)) return false;      // Remove all non digits     var formattedNumber =         cardNumber!.trim().replaceAll(new RegExp(r'[^0-9]'), '');      // Verve card needs no other validation except it matched pattern     if (CardType.fullPatternVerve.hasMatch(formattedNumber)) {       return true;     }      //check if formattedNumber is empty or card isn't a whole positive number or isn't Luhn-valid     if (StringUtils.isEmpty(formattedNumber) ||         !CardUtils.isWholeNumberPositive(cardNumber) ||         !_isValidLuhnNumber(cardNumber)) return false;      // check type lengths     if (CardType.americanExpress == _type) {       return formattedNumber.length == CardType.maxLengthAmericanExpress;     } else if (CardType.dinersClub == _type) {       return formattedNumber.length == CardType.maxLengthDinersClub;     } else {       return formattedNumber.length == CardType.maxLengthNormal;     }   }    /// Validates the number against Luhn algorithm https://de.wikipedia.org/wiki/Luhn-Algorithmus#Java   /// [number]  - number to validate   /// Returns true if the number is passes the verification.   bool _isValidLuhnNumber(String number) {     int sum = 0;     int length = number.trim().length;     for (var i = 0; i < length; i++) {       // get digits in reverse order       var source = number[length - i - 1];        // Check if character is digit before parsing it       if (!((number.codeUnitAt(i) ^ 0x30) <= 9)) {         return false;       }       int digit = int.parse(source);        // if it's odd, multiply by 2       if (i % 2 == 1) {         digit *= 2;       }       sum += digit > 9 ? (digit - 9) : digit;     }      return sum % 10 == 0;   }    @override   String toString() {     return 'PaymentCard{_cvc: $_cvc, expiryMonth: $expiryMonth, expiryYear: '         '$expiryYear, _type: $_type, _last4Digits: $_last4Digits , _number: '         '$_number}';   } }
/// This is a modification of [AlertDialog]. A lot of modifications was made. The goal is /// to retain the dialog feel and look while adding the close IconButton#6149#class CustomAlertDialog extends StatelessWidget {   const CustomAlertDialog({     Key? key,     this.title,     this.titlePadding,     this.onCancelPress,     this.contentPadding = const EdgeInsets.symmetric(vertical: 10.0),     this.expanded = false,     this.fullscreen = false,     required this.content,   }) : super(key: key);    final Widget? title;   final EdgeInsetsGeometry? titlePadding;   final Widget content;   final EdgeInsetsGeometry contentPadding;   final VoidCallback? onCancelPress;   final bool expanded;   final bool fullscreen;    @override   Widget build(BuildContext context) {     final List<Widget> children = <Widget>[];      if (title != null && titlePadding != null) {       children.add(new Padding(         padding: titlePadding!,         child: new DefaultTextStyle(           style: context.textTheme().headline6!,           child: new Semantics(child: title, namesRoute: true),         ),       ));     }      children.add(new Flexible(       child: new Padding(         padding: contentPadding,         child: new DefaultTextStyle(           style: context.textTheme().subtitle1!,           child: content,         ),       ),     ));      return buildContent(context, children);   }    Widget buildContent(context, List<Widget> children) {     Widget widget;     if (fullscreen) {       widget = new Material(         child: new Container(             child: onCancelPress == null                 ? new Padding(                     padding: const EdgeInsets.symmetric(                       horizontal: 10.0,                       vertical: 20.0,                     ),                     child: new Column(                         crossAxisAlignment: CrossAxisAlignment.start,                         children: children),                   )                 : new Column(                     crossAxisAlignment: CrossAxisAlignment.start,                     children: <Widget>[                       new Align(                         alignment: Alignment.topRight,                         child: new IconButton(                           icon: new Icon(Icons.close),                           onPressed: onCancelPress,                           color: Colors.black54,                           padding: const EdgeInsets.all(15.0),                           iconSize: 30.0,                         ),                       ),                       new Expanded(                           child: new Padding(                         padding: const EdgeInsets.symmetric(horizontal: 10.0),                         child: new Column(                           children: children,                         ),                       ))                     ],                   )),       );     } else {       var body = new Material(         type: MaterialType.card,         borderRadius: new BorderRadius.circular(10.0),         child: new Column(           mainAxisSize: MainAxisSize.min,           crossAxisAlignment: CrossAxisAlignment.stretch,           children: children,         ),       );       var child = new IntrinsicWidth(         child: onCancelPress == null             ? body             : new Column(                 mainAxisSize: MainAxisSize.min,                 mainAxisAlignment: MainAxisAlignment.center,                 crossAxisAlignment: CrossAxisAlignment.end,                 children: <Widget>[                   new Container(                     margin: const EdgeInsets.all(10.0),                     child: new IconButton(                         highlightColor: Colors.white54,                         splashColor: Colors.white54,                         color: Colors.white,                         iconSize: 30.0,                         padding: const EdgeInsets.all(3.0),                         icon: const Icon(                           Icons.cancel,                         ),                         onPressed: onCancelPress),                   ),                   new Flexible(child: body),                 ],               ),       );       widget = new CustomDialog(child: child, expanded: expanded);     }     return widget;   } } /// This is a modification of [Dialog]. The only modification is increasing the /// elevation and changing the Material type.#6149#class CustomDialog extends StatelessWidget {   const CustomDialog({     Key? key,     required this.child,     required this.expanded,     this.insetAnimationDuration = const Duration(milliseconds: 100),     this.insetAnimationCurve = Curves.decelerate,   }) : super(key: key);    final Widget child;   final Duration insetAnimationDuration;   final Curve insetAnimationCurve;   final bool expanded;    @override   Widget build(BuildContext context) {     return new AnimatedPadding(       padding: MediaQuery.of(context).viewInsets +           const EdgeInsets.symmetric(horizontal: 20.0, vertical: 24.0),       duration: insetAnimationDuration,       curve: insetAnimationCurve,       child: new MediaQuery.removeViewInsets(         removeLeft: true,         removeTop: true,         removeRight: true,         removeBottom: true,         context: context,         child: new Center(           child: new ConstrainedBox(             constraints: new BoxConstraints(                 minWidth: expanded                     ? math.min(                         (MediaQuery.of(context).size.width - 40.0), 332.0)                     : 280.0),             child: new Material(               elevation: 50.0,               type: MaterialType.transparency,               child: child,             ),           ),         ),       ),     );   } }
/// Displays an empty container that will represent a document page template with a fixed [width] and [height] /// where the user will use to pick a coordenate. /// [widgetWidth] should be called along with the [widgetHeight] in order to make the aspect ratio fit#6149#class TemplatePageWidget extends StatefulWidget {   final double width;   final double height;   final bool isLoading;   final String previewPath;    TemplatePageWidget({@required this.width, @required this.height, this.isLoading, this.previewPath}) : assert(width > 0.0 && height > 0.0);   TemplatePageState createState() => new TemplatePageState(); }
/// Function definition to build widget tree for a PDF document. /// /// [pdfDocument] is the PDF document and it is valid until the corresponding /// [PdfDocumentLoader] is in the widget tree. It may be null. /// [pageCount] indicates the number of pages in it.#6149#typedef PdfDocumentBuilder = Widget Function( /// Function definition to build widget tree corresponding to a PDF page. /// /// The function used to decorate the rendered PDF page with certain border and/or shadow /// and sometimes add page number on it. /// The second parameter [pageSize] is the original page size in pt. /// You can determine the final page size shown in the flutter UI using the size /// and then pass the size to [textureBuilder] function on the third parameter, /// which generates the final [Widget].#6149#typedef PdfPageBuilder = Widget Function( /// Function definition to generate the actual widget that contains rendered PDF page image. /// /// [size] should be the page widget size but it can be null if you don't want to calculate it. /// Unlike the function name, it may generate widget other than [Texture]. /// the function generates a placeholder [Container] for the unavailable page image. /// Anyway, please note that the size is in screen coordinates; not the actual pixel size of /// the image. In other words, the function correctly deals with the screen pixel density automatically. /// [backgroundFill] specifies whether to fill background before rendering actual page content or not. /// The page content may not have background fill and if the flag is false, it may be rendered with transparent /// background. /// [renderingPixelRatio] specifies pixel density for rendering page image. If it is null, the value is obtained by /// calling `MediaQuery.of(context).devicePixelRatio`. /// Please note that on iOS Simulator, it always use non-[Texture] rendering pass.#6149#typedef PdfPageTextureBuilder = Widget Function( /// Creates page placeholder that is shown on page loading or even page load failure.#6149#typedef PdfPagePlaceholderBuilder = Widget Function( /// Page loading status.#6149#enum PdfPageStatus {   /// The page is currently being loaded.   loading,    /// The page load failed.   loadFailed, } /// Error handler.#6149#typedef OnError = void Function(dynamic); /// Exception-proof await/cache mechanism on [PdfDocument] Future.#6149#class _PdfDocumentAwaiter {   _PdfDocumentAwaiter(this._docFuture, {this.onError});    final FutureOr<PdfDocument> _docFuture;   final OnError? onError;   PdfDocument? _cached;    Future<PdfDocument?> getValue() async {     if (_cached == null) {       try {         _cached = await _docFuture;       } catch (e) {         onError?.call(e);       }     }     return _cached;   } } /// [PdfDocumentLoader] is a [Widget] that used to load arbitrary PDF document and manages [PdfDocument] instance.#6149#class PdfDocumentLoader extends StatefulWidget {   final FutureOr<PdfDocument> doc;    /// Function to build widget tree corresponding to PDF document.   final PdfDocumentBuilder? documentBuilder;    /// Page number of the page to render if only one page should be shown.   ///   /// Could not be used with [documentBuilder].   /// If you want to show multiple pages in the widget tree, use [PdfPageView].   final int? pageNumber;    /// Function to build page widget tree.   ///   /// It can be null if you don't want to render the page with the widget or use the default page builder.   final PdfPageBuilder? pageBuilder;    /// Error callback   final Function(dynamic)? onError;    /// Load PDF document from file.   ///   /// For additional parameters, see [PdfDocumentLoader].   factory PdfDocumentLoader.openFile(     String filePath, {     Key? key,     PdfDocumentBuilder? documentBuilder,     int? pageNumber,     PdfPageBuilder? pageBuilder,     Function(dynamic)? onError,   }) =>       PdfDocumentLoader(         key: key,         doc: PdfDocument.openFile(filePath),         documentBuilder: documentBuilder,         pageNumber: pageNumber,         pageBuilder: pageBuilder,         onError: onError,       );    /// Load PDF document from asset.   ///   /// For additional parameters, see [PdfDocumentLoader].   factory PdfDocumentLoader.openAsset(     String assetName, {     Key? key,     PdfDocumentBuilder? documentBuilder,     int? pageNumber,     PdfPageBuilder? pageBuilder,     Function(dynamic)? onError,   }) =>       PdfDocumentLoader(         key: key,         doc: PdfDocument.openAsset(assetName),         documentBuilder: documentBuilder,         pageNumber: pageNumber,         pageBuilder: pageBuilder,         onError: onError,       );    /// Load PDF document from PDF binary data.   ///   /// For additional parameters, see [PdfDocumentLoader].   factory PdfDocumentLoader.openData(     Uint8List data, {     Key? key,     PdfDocumentBuilder? documentBuilder,     int? pageNumber,     PdfPageBuilder? pageBuilder,     Function(dynamic)? onError,   }) =>       PdfDocumentLoader(         key: key,         doc: PdfDocument.openData(data),         documentBuilder: documentBuilder,         pageNumber: pageNumber,         pageBuilder: pageBuilder,         onError: onError,       );    /// Use one of [PdfDocumentLoader.openFile], [PdfDocumentLoader.openAsset],   /// or [PdfDocumentLoader.openData] in normal case.   /// If you already have [PdfDocument], you can use the method.   PdfDocumentLoader({     Key? key,     required this.doc,     this.documentBuilder,     this.pageNumber,     this.pageBuilder,     this.onError,   }) : super(key: key);    @override   PdfDocumentLoaderState createState() => PdfDocumentLoaderState();    /// Error-safe wrapper on [doc].   late final _docCache = _PdfDocumentAwaiter(doc, onError: onError); } /// Widget to render a page of PDF document. Normally used in combination with [PdfDocumentLoader].#6149#class PdfPageView extends StatefulWidget {   /// [PdfDocument] to render. If it is null, the actual document is obtained by locating ancestor [PdfDocumentLoader]   /// widget.   final PdfDocument? pdfDocument;    /// Page number of the page to render if only one page should be shown.   final int? pageNumber;    /// Function to build page widget tree. It can be null if you want to use the default page builder.   final PdfPageBuilder? pageBuilder;    const PdfPageView(       {Key? key, this.pdfDocument, required this.pageNumber, this.pageBuilder})       : super(key: key);    @override   PdfPageViewState createState() => PdfPageViewState(); } /// Specifies where to anchor to.#6149#enum PdfViewerAnchor {   topLeft,   top,   topRight,   left,   center,   right,   bottomLeft,   bottom,   bottomRight, } /// Controller for [PdfViewer]. /// It is derived from [TransformationController] and basically compatible to [ValueNotifier<Matrix4>]. /// So you can pass it to [ValueListenableBuilder<Matrix4>] or such to receive any view status changes.#6149#class PdfViewerController extends TransformationController {   PdfViewerController();    /// Associated [PdfViewerState].   ///   /// FIXME: I don't think this is a good structure for our purpose...   PdfViewerState? _state;    /// Associate a [PdfViewerState] to the controller.   void _setViewerState(PdfViewerState? state) {     _state = state;     if (_state != null) notifyListeners();   }    /// Whether the controller is ready or not.   ///   /// If the controller is not ready, almost all methods on [PdfViewerController] won't work (throw some exception).   /// For certain operations, it may be easier to use [ready] method to get [PdfViewerController?] not to execute   /// methods unless it is ready.   bool get isReady => _state?._pages != null;    /// Helper method to return null when the controller is not ready([isReady]).   ///   /// It is useful if you want ot call methods like [goTo] with the property like the following fragment:   /// ```dart   /// controller.ready?.goToPage(pageNumber: 1);   /// ```   PdfViewerController? get ready => isReady ? this : null;    /// Get total page count in the PDF document.   ///   /// If the controller is not ready([isReady]), the property throws an exception.   int get pageCount => _state!._pages!.length;    /// Get page location. If the page does not exist in the layout, it returns null.   ///   /// If the controller is not ready([isReady]), the property throws an exception.   Rect? getPageRect(int pageNumber) => _state!._pages![pageNumber - 1].rect;    /// Calculate maximum X that can be acceptable as a horizontal scroll position.   double _getScrollableMaxX(double zoomRatio) =>       _state!._docSize!.width * zoomRatio - _state!._lastViewSize!.width;    /// Calculate maximum Y that can be acceptable as a vertical scroll position.   double _getScrollableMaxY(double zoomRatio) =>       _state!._docSize!.height * zoomRatio - _state!._lastViewSize!.height;    /// Clip horizontal scroll position.   double _clipX(double x, double zoomRatio) =>       max(0.0, min(x, _getScrollableMaxX(zoomRatio)));    /// Clip vertical scroll position.   double _clipY(double y, double zoomRatio) =>       max(0.0, min(y, _getScrollableMaxY(zoomRatio)));    /// Calculate the matrix that corresponding to the page position.   ///   /// If the page does not exist in the layout, it returns null.   /// If the controller is not ready([isReady]), the method throws an exception.   Matrix4? calculatePageFitMatrix({required int pageNumber, double? padding}) =>       calculatePageMatrix(           pageNumber: pageNumber,           padding: padding,           x: 0,           y: 0,           anchor: PdfViewerAnchor.topLeft);    /// Calculate the matrix that corresponding to the page of specified offset ([x], [y]) and specified [zoomRatio].   ///   /// [x],[y] should be in [0 1] range and they indicate relative position in the page:   /// - 0 for top/left   /// - 1 for bottom/right   /// - 0.5 for center (the default)   ///   /// [anchor] specifies which widget corner, edge, or center the point specified by ([x],[y]) is anchored to.   ///   /// [zoomRatio] specifies the zoom ratio. The default is to use the zoom ratio that fit the page into the view.   /// If you want to keep the current zoom ratio, use [PdfViewerController.zoomRatio] for the value.   ///   /// If the page does not exist in the layout, it returns null.   /// If the controller is not ready([isReady]), the method throws an exception.   Matrix4? calculatePageMatrix({     required int pageNumber,     double? padding,     double x = 0.5,     double y = 0.5,     PdfViewerAnchor anchor = PdfViewerAnchor.center,     double? zoomRatio,   }) {     final rect = getPageRect(pageNumber)?.inflate(padding ?? _state!._padding);     if (rect == null) return null;     final zoom1 = _state!._lastViewSize!.width / rect.width;     final destZoom = zoomRatio ?? zoom1;     final ratio = destZoom / zoom1;     final viewWidth = _state!._lastViewSize!.width;     final viewHeight = _state!._lastViewSize!.height;     final left = _clipX(         (rect.left + rect.width * x) * ratio -             viewWidth * (anchor.index % 3) / 2,         destZoom);     final top = _clipY(         (rect.top + rect.height * y) * ratio -             viewHeight * (anchor.index ~/ 3) / 2,         destZoom);      return Matrix4.compose(       math64.Vector3(-left, -top, 0),       math64.Quaternion.identity(),       math64.Vector3(destZoom, destZoom, 1),     );   }    /// Go to the destination specified by the matrix.   ///   /// To go to a specific page, use [goToPage] method or use [calculatePageFitMatrix]/[calculatePageMatrix] method to calculate the page   /// location matrix.   /// If [destination] is null, the method does nothing.   Future<void> goTo({     Matrix4? destination,     Duration duration = const Duration(milliseconds: 200),   }) =>       _state!._goTo(         destination: destination,         duration: duration,       );    /// Go to the specified page.   Future<void> goToPage({     required int pageNumber,     double? padding,     Duration duration = const Duration(milliseconds: 500),   }) =>       goTo(         destination:             calculatePageFitMatrix(pageNumber: pageNumber, padding: padding),         duration: duration,       );    /// Go to specific point in page.   ///   /// [x],[y] should be in [0 1] range and they indicate relative position in the page:   /// - 0 for top/left   /// - 1 for bottom/right   /// - 0.5 for center (the default)   ///   /// [anchor] specifies which widget corner, edge, or center the point specified by ([x],[y]) is anchored to.   ///   /// [zoomRatio] specifies the zoom ratio. The default is to use the zoom ratio that fit the page into the view.   /// If you want to keep the current zoom ratio, use [PdfViewerController.zoomRatio] for the value.   ///   /// If the page does not exist in the layout, it returns null.   /// If the controller is not ready([isReady]), the method throws an exception.   Future<void> goToPointInPage({     required int pageNumber,     double? padding,     double x = 0.5,     double y = 0.5,     PdfViewerAnchor anchor = PdfViewerAnchor.center,     double? zoomRatio,     Duration duration = const Duration(milliseconds: 500),   }) =>       goTo(         destination: calculatePageMatrix(           pageNumber: pageNumber,           padding: padding,           x: x,           y: y,           zoomRatio: zoomRatio,           anchor: anchor,         ),         duration: duration,       );    /// Calculate the matrix that changes zoom ratio.   ///   /// [center] specifies the center of the zoom operation in widget's "local" coordinates. e.g. [TapDownDetails.localPosition]   Matrix4 zoomMatrix(double zoomRatio, {Offset? center}) {     final ratio = zoomRatio / this.zoomRatio;     final offset = this.offset;     final dx = center?.dx ?? _state!._lastViewSize!.width * 0.5;     final dy = center?.dy ?? _state!._lastViewSize!.height * 0.5;     final left = _clipX((offset.dx + dx) * ratio - dx, zoomRatio);     final top = _clipY((offset.dy + dy) * ratio - dy, zoomRatio);     return Matrix4.compose(       math64.Vector3(-left, -top, 0),       math64.Quaternion.identity(),       math64.Vector3(zoomRatio, zoomRatio, 1),     );   } /// A PDF viewer implementation with user interactive zooming support.#6149#class PdfViewer extends StatefulWidget {   /// PDF document instance.   final FutureOr<PdfDocument> doc;    /// Controller for the viewer. If none is specified, the viewer initializes one internally.   final PdfViewerController? viewerController;    /// Additional parameter to configure the viewer.   final PdfViewerParams? params;    /// Error handler.   final OnError? onError;    /// Error-safe wrapper on [doc].   late final _docCache = _PdfDocumentAwaiter(doc, onError: onError);    Future<PdfDocument?> get _doc => _docCache.getValue();    PdfViewer({     Key? key,     required this.doc,     this.viewerController,     this.params,     this.onError,   }) : super(key: key);    /// Open a file.   factory PdfViewer.openFile(     String filePath, {     Key? key,     PdfViewerController? viewerController,     PdfViewerParams? params,     OnError? onError,   }) =>       PdfViewer(         key: key,         doc: PdfDocument.openFile(filePath),         viewerController: viewerController,         params: params,         onError: onError,       );    /// Open an asset.   factory PdfViewer.openAsset(     String assetPath, {     Key? key,     PdfViewerController? viewerController,     PdfViewerParams? params,     OnError? onError,   }) =>       PdfViewer(         key: key,         doc: PdfDocument.openAsset(assetPath),         viewerController: viewerController,         params: params,         onError: onError,       );    /// Open PDF data on byte array.   factory PdfViewer.openData(     Uint8List data, {     Key? key,     PdfViewerController? viewerController,     PdfViewerParams? params,     OnError? onError,   }) =>       PdfViewer(         key: key,         doc: PdfDocument.openData(data),         viewerController: viewerController,         params: params,         onError: onError,       );    /// Open PDF from the filename returned by async function.   static Widget openFutureFile(     Future<String> Function() getFilePath, {     Key? key,     PdfViewerController? viewerController,     PdfViewerParams? params,     OnError? onError,     Widget Function(BuildContext)? loadingBannerBuilder,     PdfDocument? docFallback,   }) =>       openFuture(         getFilePath,         PdfDocument.openFile,         key: key,         viewerController: viewerController,         params: params,         onError: onError,         loadingBannerBuilder: loadingBannerBuilder,         docFallback: docFallback,       );    /// Open PDF data on byte array returned by async function.   static Widget openFutureData(     Future<Uint8List> Function() getData, {     Key? key,     PdfViewerController? viewerController,     PdfViewerParams? params,     OnError? onError,     Widget Function(BuildContext)? loadingBannerBuilder,     PdfDocument? docFallback,   }) =>       openFuture(         getData,         PdfDocument.openData,         key: key,         viewerController: viewerController,         params: params,         onError: onError,         loadingBannerBuilder: loadingBannerBuilder,         docFallback: docFallback,       );    /// Open PDF using async function.   static Widget openFuture<T>(     Future<T> Function() getFuture,     Future<PdfDocument> Function(T) futureToDocument, {     Key? key,     PdfViewerController? viewerController,     PdfViewerParams? params,     OnError? onError,     Widget Function(BuildContext)? loadingBannerBuilder,     PdfDocument? docFallback,   }) =>       FutureBuilder<T>(         key: key,         future: getFuture(),         builder: (context, snapshot) {           if (snapshot.hasData) {             return PdfViewer(               doc: futureToDocument(snapshot.data!),               viewerController: viewerController,               params: params,               onError: onError,             );           } else if (loadingBannerBuilder != null) {             return Builder(builder: loadingBannerBuilder);           } else if (docFallback != null) {             return PdfViewer(               doc: Future.value(docFallback),               viewerController: viewerController,               params: params,               onError: onError,             );           }           return Container(); // ultimate fallback         },       );    @override   PdfViewerState createState() => PdfViewerState(); } /// RealSize overlay.#6149#@immutable /// Internal page control structure.#6149#class _PdfPageState {   /// Page number (started at 1).   final int pageNumber;    /// [PdfPage] corresponding to the page if available.   late final PdfPage pdfPage;    /// Where the page is layed out if available. It can be null to not show in the view.   Rect? rect;    /// Size at 72-dpi. During the initialization, the size may be just a copy of the size of the first page.   Size pageSize;    /// Preview image of the page rendered at low resolution.   PdfPageImageTexture? preview;    final _textures = <PdfPageImageTexture?>[null, null];    int _textureId = 0;    /// realSize overlay.   final realSize = ValueNotifier<_RealSize?>(null);    /// Whether the page is visible within the view or not.   bool isVisibleInsideView = false;    _PdfPageLoadingStatus status = _PdfPageLoadingStatus.notInitialized;    final _previewNotifier = ValueNotifier<int>(0);    _PdfPageState._({required this.pageNumber, required this.pageSize});    void updatePreview() {     if (status != _PdfPageLoadingStatus.disposed) _previewNotifier.value++;   }    void _updateRealSizeOverlay(_RealSize tex) {     if (status != _PdfPageLoadingStatus.disposed) realSize.value = tex;   }    bool releaseRealSize() {     realSize.value = null;     _textures[0]?.dispose();     _textures[0] = null;     _textures[1]?.dispose();     _textures[1] = null;     return true;   }    /// Release allocated textures.   ///   /// It's always safe to call the method. If all the textures were already released, the method does nothing.   /// Returns true if textures are really released; otherwise if the method does nothing and returns false.   bool releaseTextures() => _releaseTextures(_PdfPageLoadingStatus.initialized);    bool _releaseTextures(_PdfPageLoadingStatus newStatus) {     preview?.dispose();     preview = null;     releaseRealSize();     status = newStatus;     return true;   }    void dispose() {     _releaseTextures(_PdfPageLoadingStatus.disposed);     _previewNotifier.dispose();     realSize.dispose();   } }
/// Handles PDF document loaded on memory.#6149#class PdfDocumentMethodChannel extends PdfDocument {   /// Document-ID that uniquely identifies the current instance.   final int docId;    final List<PdfPage?> _pages;    PdfDocumentMethodChannel._({     required String sourceName,     required this.docId,     required int pageCount,     required int verMajor,     required int verMinor,     required bool isEncrypted,     required bool allowsCopying,     required bool allowsPrinting,   })  : _pages = List<PdfPage?>.filled(pageCount, null),         super(             sourceName: sourceName,             pageCount: pageCount,             verMajor: verMajor,             verMinor: verMinor,             isEncrypted: isEncrypted,             allowsCopying: allowsCopying,             allowsPrinting: allowsPrinting);    @override   Future<void> dispose() async {     await _channel.invokeMethod('close', docId);   }    /// Get page object. The first page is 1.   @override   Future<PdfPage> getPage(int pageNumber) async {     if (pageNumber < 1 || pageNumber > pageCount) {       throw RangeError.range(pageNumber, 1, pageCount, 'pageNumber');     }     var page = _pages[pageNumber - 1];     if (page == null) {       var obj = (await _channel.invokeMethod<Map<dynamic, dynamic>>(           'page', {"docId": docId, "pageNumber": pageNumber}))!;       page = _pages[pageNumber - 1] = PdfPageMethodChannel._(         document: this,         pageNumber: pageNumber,         width: obj['width'] as double,         height: obj['height'] as double,       );     }     return page;   }    @override   bool operator ==(dynamic other) =>       other is PdfDocumentMethodChannel && other.docId == docId;    @override   int get hashCode => docId;    @override   String toString() => sourceName; } /// Handles a PDF page in [PDFDocument].#6149#class PdfPageMethodChannel extends PdfPage {   PdfPageMethodChannel._(       {required PdfDocumentMethodChannel document,       required int pageNumber,       required double width,       required double height})       : super(             document: document,             pageNumber: pageNumber,             width: width,             height: height);    @override   Future<PdfPageImage> render({     int x = 0,     int y = 0,     int? width,     int? height,     double? fullWidth,     double? fullHeight,     bool? backgroundFill,     bool? allowAntialiasingIOS,   }) async {     return PdfPageImageMethodChannel._render(       document as PdfDocumentMethodChannel,       pageNumber,       x: x,       y: y,       width: width,       height: height,       fullWidth: fullWidth,       fullHeight: fullHeight,       backgroundFill: backgroundFill,       allowAntialiasingIOS: allowAntialiasingIOS,     );   }    @override   bool operator ==(dynamic other) =>       other is PdfPageMethodChannel &&       other.document == document &&       other.pageNumber == pageNumber;    @override   int get hashCode => document.hashCode ^ pageNumber;    @override   String toString() => '$document:page=$pageNumber'; } /// Very limited support for Flutter's [Texture] based drawing. /// Because it does not transfer the rendered image via platform channel, /// it could be faster and more efficient than the [PdfPageImage] based rendering process.#6149#class PdfPageImageTextureMethodChannel extends PdfPageImageTexture {   int? _texWidth;   int? _texHeight;    @override   int? get texWidth => _texWidth;   @override   int? get texHeight => _texHeight;   @override   bool get hasUpdatedTexture => _texWidth != null;    @override   bool operator ==(Object other) {     return other is PdfPageImageTextureMethodChannel &&         other.pdfDocument == pdfDocument &&         other.pageNumber == pageNumber;   }    PdfDocumentMethodChannel get _doc => pdfDocument as PdfDocumentMethodChannel;    @override   int get hashCode => _doc.docId ^ pageNumber;    PdfPageImageTextureMethodChannel._(       {required PdfDocument pdfDocument,       required int pageNumber,       required int texId})       : super(pdfDocument: pdfDocument, pageNumber: pageNumber, texId: texId);    /// Release the object.   @override   Future<void> dispose() => _channel.invokeMethod('releaseTex', texId);    /// Extract sub-rectangle ([x],[y],[width],[height]) of the PDF page scaled to [fullWidth] x [fullHeight] size.   /// If [backgroundFill] is true, the sub-rectangle is filled with white before rendering the page content.   /// Returns true if succeeded.   /// Returns true if succeeded.   @override   Future<bool> extractSubrect(       {int x = 0,       int y = 0,       required int width,       required int height,       double? fullWidth,       double? fullHeight,       bool backgroundFill = true,       bool allowAntialiasingIOS = true}) async {     final result = (await _channel.invokeMethod<int>('updateTex', {       'docId': _doc.docId,       'pageNumber': pageNumber,       'texId': texId,       'width': width,       'height': height,       'srcX': x,       'srcY': y,       'fullWidth': fullWidth,       'fullHeight': fullHeight,       'backgroundFill': backgroundFill,       'allowAntialiasingIOS': allowAntialiasingIOS,     }))!;     if (result >= 0) {       _texWidth = width;       _texHeight = height;     }     return result >= 0;   } }
/// Handles PDF document loaded on memory.#6149#abstract class PdfDocument {   /// File path, `asset:[ASSET_PATH]` or `memory:` depending on the content opened.   final String sourceName;    /// Number of pages in the PDF document.   final int pageCount;    /// PDF major version.   final int verMajor;    /// PDF minor version.   final int verMinor;    /// Determine whether the PDF file is encrypted or not.   final bool isEncrypted;    /// Determine whether the PDF file allows copying of the contents.   final bool allowsCopying;    /// Determine whether the PDF file allows printing of the pages.   final bool allowsPrinting;    PdfDocument({     required this.sourceName,     required this.pageCount,     required this.verMajor,     required this.verMinor,     required this.isEncrypted,     required this.allowsCopying,     required this.allowsPrinting,   });    Future<void> dispose();    /// Opening the specified file.   /// For Web, [filePath] can be relative path from `index.html` or any arbitrary URL but it may be restricted by CORS.   static Future<PdfDocument> openFile(String filePath) =>       PdfRenderPlatform.instance.openFile(filePath);    /// Opening the specified asset.   static Future<PdfDocument> openAsset(String name) =>       PdfRenderPlatform.instance.openAsset(name);    /// Opening the PDF on memory.   static Future<PdfDocument> openData(Uint8List data) =>       PdfRenderPlatform.instance.openData(data);    /// Get page object. The first page is 1.   Future<PdfPage> getPage(int pageNumber);    @override   bool operator ==(dynamic other);    @override   int get hashCode;    @override   String toString() => sourceName; } /// Handles a PDF page in [PDFDocument].#6149#abstract class PdfPage {   /// PDF document.   final PdfDocument document;    /// Page number. The first page is 1.   final int pageNumber;    /// PDF page width in points (width in pixels at 72 dpi) (rotated).   final double width;    /// PDF page height in points (height in pixels at 72 dpi) (rotated).   final double height;    PdfPage({     required this.document,     required this.pageNumber,     required this.width,     required this.height,   });    /// Render a sub-area or full image of specified PDF file.   /// [x], [y], [width], [height] specify sub-area to render in pixels.   /// [fullWidth], [fullHeight] specify virtual full size of the page to render in pixels. If they're not specified, [width] and [height] are used to specify the full size.   /// If [width], [height], [fullWidth], [fullHeight], and [dpi] are all 0, the page is rendered at 72 dpi.   /// By default, [backgroundFill] is true and the page background is once filled with white before rendering page image but you can turn it off if needed.   /// ![](./images/render-params.png)   Future<PdfPageImage> render({     int x = 0,     int y = 0,     int? width,     int? height,     double? fullWidth,     double? fullHeight,     bool backgroundFill = true,     bool allowAntialiasingIOS = false,   });    @override   bool operator ==(dynamic other) =>       other is PdfPage &&       other.document == document &&       other.pageNumber == pageNumber;    @override   int get hashCode => document.hashCode ^ pageNumber;    @override   String toString() => '$document:page=$pageNumber'; } /// Very limited support for Flutter's [Texture] based drawing. /// Because it does not transfer the rendered image via platform channel, /// it could be faster and more efficient than the [PdfPageImage] based rendering process.#6149#abstract class PdfPageImageTexture {   final PdfDocument pdfDocument;   final int pageNumber;   final int texId;    int? get texWidth;   int? get texHeight;   bool get hasUpdatedTexture;    @override   bool operator ==(Object other);    @override   int get hashCode;    PdfPageImageTexture(       {required this.pdfDocument,       required this.pageNumber,       required this.texId});    /// Create a new Flutter [Texture]. The object should be released by calling [dispose] method after use it.   static Future<PdfPageImageTexture> create(           {required FutureOr<PdfDocument> pdfDocument,           required int pageNumber}) =>       PdfRenderPlatform.instance           .createTexture(pdfDocument: pdfDocument, pageNumber: pageNumber);    /// Release the object.   Future<void> dispose();    /// Extract sub-rectangle ([x],[y],[width],[height]) of the PDF page scaled to [fullWidth] x [fullHeight] size.   /// If [backgroundFill] is true, the sub-rectangle is filled with white before rendering the page content.   /// Returns true if succeeded.   Future<bool> extractSubrect({     int x = 0,     int y = 0,     required int width,     required int height,     double? fullWidth,     double? fullHeight,     bool backgroundFill = true,   }); }
/// Abstraction layer to isolate [PdfDocument]/[PdfPageImageTexture] implementation from the public interface.#6149#abstract class PdfRenderPlatform extends PlatformInterface {   /// Constructs a PdfRenderPlatform.   PdfRenderPlatform() : super(token: _token);    static final Object _token = Object();    static PdfRenderPlatform _instance = PdfRenderPlatformMethodChannel();    /// The default instance of [PdfRenderPlatform] to use.   ///   /// Defaults to [MethodChannelUrlLauncher].   static PdfRenderPlatform get instance => _instance;    /// Platform-specific plugins should set this with their own platform-specific   /// class that extends [PdfRenderPlatform] when they register themselves.   static set instance(PdfRenderPlatform instance) {     PlatformInterface.verifyToken(instance, _token);     _instance = instance;   }    /// Opening the specified file.   Future<PdfDocument> openFile(String filePath);    /// Opening the specified asset.   Future<PdfDocument> openAsset(String name);    /// Opening the PDF on memory.   Future<PdfDocument> openData(Uint8List data);    /// Create a new Flutter [Texture]. The object should be released by calling [dispose] method after use it.   Future<PdfPageImageTexture> createTexture({required FutureOr<PdfDocument> pdfDocument, required int pageNumber}); }
/// [Uint8] is not defined for Flutter Web. This is just a dummy definition.#6149#class Uint8 {} /// Works only for [Uint8];#6149#class Pointer<T> {   final int _address;   Pointer._(this._address);   factory Pointer.fromAddress(int address) => Pointer._(address);    int get address => _address;   Uint8List get buffer => getBufferByFakeAddress(address); } /// Get buffer for Pointer<Uint8>.#6149#extension Uint8Pointer on Pointer<Uint8> {   Uint8List asTypedList(int length) => buffer; } /// Associate an address with the specified buffer and return the address.#6149#int pinBufferByFakeAddress(Uint8List buffer) {   js_util.setProperty(html.window, 'pdf_render_buffer_$_fakeAddress', buffer);   return _fakeAddress++; } /// Get the associated buffer for the address.#6149#Uint8List getBufferByFakeAddress(int address) {   return js_util.getProperty(html.window, 'pdf_render_buffer_$address') as Uint8List; } /// Release the associated buffer for the address.#6149#void unpinBufferByFakeAddress(int address) {   js_util.setProperty(html.window, 'pdf_render_buffer_$address', null); }
/// ignore: unused_element#6149#  _BatchTimeline call( // ignore: unused_element#6149#  BatchTimeline fromJson(Map<String, Object> json) {     return BatchTimeline.fromJson(json);   } // ignore: unused_element#6149#const $BatchTimeline = _$BatchTimelineTearOff();
/// import 'package:add_thumbnail/add_thumbnail.dart';#6149#import 'package:file_picker/file_picker.dart';
/// import 'package:flutter_twitter_clone/helper/utility.dart';#6149#class UrlText extends StatelessWidget {   final String text;   final TextStyle style;   final TextStyle urlStyle;   final Function(String) onHashTagPressed;    UrlText({this.text, this.style, this.urlStyle, this.onHashTagPressed});    List<InlineSpan> getTextSpans() {     List<InlineSpan> widgets = List<InlineSpan>();     RegExp reg = RegExp(         r"([#])\w+| [@]\w+|(https?|ftp|file|#)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]*");     Iterable<Match> _matches = reg.allMatches(text);     List<_ResultMatch> resultMatches = List<_ResultMatch>();     int start = 0;     for (Match match in _matches) {       if (match.group(0).isNotEmpty) {         if (start != match.start) {           _ResultMatch result1 = _ResultMatch();           result1.isUrl = false;           result1.text = text.substring(start, match.start);           resultMatches.add(result1);         }          _ResultMatch result2 = _ResultMatch();         result2.isUrl = true;         result2.text = match.group(0);         resultMatches.add(result2);         start = match.end;       }     }     if (start < text.length) {       _ResultMatch result1 = _ResultMatch();       result1.isUrl = false;       result1.text = text.substring(start);       resultMatches.add(result1);     }     for (var result in resultMatches) {       if (result.isUrl) {         widgets.add(_LinkTextSpan(             onHashTagPressed: onHashTagPressed,             text: result.text,             style:                 urlStyle != null ? urlStyle : TextStyle(color: Colors.blue)));       } else {         widgets.add(TextSpan(             text: result.text,             style: style != null ? style : TextStyle(color: Colors.black)));       }     }     return widgets;   }    @override   Widget build(BuildContext context) {     return RichText(       text: TextSpan(children: getTextSpans()),     );   } }
/// ignore: must_be_immutable#6149#class CircularPercentIndicator extends StatefulWidget {   ///Percent value between 0.0 and 1.0   final double percent;   final double radius;    ///Width of the progress bar of the circle   final double lineWidth;    ///Width of the unfilled background of the progress bar   final double backgroundWidth;    ///First color applied to the complete circle   final Color fillColor;    ///Color of the background of the circle , default = transparent   final Color backgroundColor;    Color get progressColor => _progressColor;    late Color _progressColor;    ///true if you want the circle to have animation   final bool animation;    ///duration of the animation in milliseconds, It only applies if animation attribute is true   final int animationDuration;    ///widget at the top of the circle   final Widget? header;    ///widget at the bottom of the circle   final Widget? footer;    ///widget inside the circle   final Widget? center;    final LinearGradient? linearGradient;    ///The kind of finish to place on the end of lines drawn, values supported: butt, round, square   final CircularStrokeCap circularStrokeCap;    ///the angle which the circle will start the progress (in degrees, eg: 0.0, 45.0, 90.0)   final double startAngle;    /// set true if you want to animate the linear from the last percent value you set   final bool animateFromLastPercent;    /// set false if you don't want to preserve the state of the widget   final bool addAutomaticKeepAlive;    /// set the arc type   final ArcType? arcType;    /// set a circular background color when use the arcType property   final Color? arcBackgroundColor;    /// set true when you want to display the progress in reverse mode   final bool reverse;    /// Creates a mask filter that takes the progress shape being drawn and blurs it.   final MaskFilter? maskFilter;    /// set a circular curve animation type   final Curve curve;    /// set true when you want to restart the animation, it restarts only when reaches 1.0 as a value   /// defaults to false   final bool restartAnimation;    /// Callback called when the animation ends (only if `animation` is true)   final VoidCallback? onAnimationEnd;    /// Display a widget indicator at the end of the progress. It only works when `animation` is true   final Widget? widgetIndicator;    /// Set to true if you want to rotate linear gradient in accordance to the [startAngle].   final bool rotateLinearGradient;    CircularPercentIndicator({     Key? key,     this.percent = 0.0,     this.lineWidth = 5.0,     this.startAngle = 0.0,     required this.radius,     this.fillColor = Colors.transparent,     this.backgroundColor = const Color(0xFFB8C7CB),     Color? progressColor,     //negative values ignored, replaced with lineWidth     this.backgroundWidth = -1,     this.linearGradient,     this.animation = false,     this.animationDuration = 500,     this.header,     this.footer,     this.center,     this.addAutomaticKeepAlive = true,     this.circularStrokeCap = CircularStrokeCap.butt,     this.arcBackgroundColor,     this.arcType,     this.animateFromLastPercent = false,     this.reverse = false,     this.curve = Curves.linear,     this.maskFilter,     this.restartAnimation = false,     this.onAnimationEnd,     this.widgetIndicator,     this.rotateLinearGradient = false,   }) : super(key: key) {     if (linearGradient != null && progressColor != null) {       throw ArgumentError(           'Cannot provide both linearGradient and progressColor');     }     _progressColor = progressColor ?? Colors.red;      assert(startAngle >= 0.0);     if (percent < 0.0 || percent > 1.0) {       throw Exception(           "Percent value must be a double between 0.0 and 1.0, but it's $percent");     }      if (arcType == null && arcBackgroundColor != null) {       throw ArgumentError('arcType is required when you arcBackgroundColor');     }   }    @override   _CircularPercentIndicatorState createState() =>       _CircularPercentIndicatorState(); }
/// ignore: must_be_immutable#6149#class LinearPercentIndicator extends StatefulWidget {   ///Percent value between 0.0 and 1.0   final double percent;   final double? width;    ///Height of the line   final double lineHeight;    ///Color of the background of the Line , default = transparent   final Color fillColor;    ///First color applied to the complete line   Color get backgroundColor => _backgroundColor;   late Color _backgroundColor;    ///First color applied to the complete line   final LinearGradient? linearGradientBackgroundColor;    Color get progressColor => _progressColor;    late Color _progressColor;    ///true if you want the Line to have animation   final bool animation;    ///duration of the animation in milliseconds, It only applies if animation attribute is true   final int animationDuration;    ///widget at the left of the Line   final Widget? leading;    ///widget at the right of the Line   final Widget? trailing;    ///widget inside the Line   final Widget? center;    ///The kind of finish to place on the end of lines drawn, values supported: butt, round, roundAll   @Deprecated('This property is no longer used, please use barRadius instead.')   final LinearStrokeCap? linearStrokeCap;    /// The border radius of the progress bar (Will replace linearStrokeCap)   final Radius? barRadius;    ///alignment of the Row (leading-widget-center-trailing)   final MainAxisAlignment alignment;    ///padding to the LinearPercentIndicator   final EdgeInsets padding;    /// set true if you want to animate the linear from the last percent value you set   final bool animateFromLastPercent;    /// If present, this will make the progress bar colored by this gradient.   ///   /// This will override [progressColor]. It is an error to provide both.   final LinearGradient? linearGradient;    /// set false if you don't want to preserve the state of the widget   final bool addAutomaticKeepAlive;    /// set true if you want to animate the linear from the right to left (RTL)   final bool isRTL;    /// Creates a mask filter that takes the progress shape being drawn and blurs it.   final MaskFilter? maskFilter;    /// Set true if you want to display only part of [linearGradient] based on percent value   /// (ie. create 'VU effect'). If no [linearGradient] is specified this option is ignored.   final bool clipLinearGradient;    /// set a linear curve animation type   final Curve curve;    /// set true when you want to restart the animation, it restarts only when reaches 1.0 as a value   /// defaults to false   final bool restartAnimation;    /// Callback called when the animation ends (only if `animation` is true)   final VoidCallback? onAnimationEnd;    /// Display a widget indicator at the end of the progress. It only works when `animation` is true   final Widget? widgetIndicator;    LinearPercentIndicator({     Key? key,     this.fillColor = Colors.transparent,     this.percent = 0.0,     this.lineHeight = 5.0,     this.width,     Color? backgroundColor,     this.linearGradientBackgroundColor,     this.linearGradient,     Color? progressColor,     this.animation = false,     this.animationDuration = 500,     this.animateFromLastPercent = false,     this.isRTL = false,     this.leading,     this.trailing,     this.center,     this.addAutomaticKeepAlive = true,     this.linearStrokeCap,     this.barRadius,     this.padding = const EdgeInsets.symmetric(horizontal: 10.0),     this.alignment = MainAxisAlignment.start,     this.maskFilter,     this.clipLinearGradient = false,     this.curve = Curves.linear,     this.restartAnimation = false,     this.onAnimationEnd,     this.widgetIndicator,   }) : super(key: key) {     if (linearGradient != null && progressColor != null) {       throw ArgumentError(           'Cannot provide both linearGradient and progressColor');     }     _progressColor = progressColor ?? Colors.red;      if (linearGradientBackgroundColor != null && backgroundColor != null) {       throw ArgumentError(           'Cannot provide both linearGradientBackgroundColor and backgroundColor');     }     _backgroundColor = backgroundColor ?? Color(0xFFB8C7CB);      if (percent < 0.0 || percent > 1.0) {       throw new Exception(           "Percent value must be a double between 0.0 and 1.0, but it's $percent");     }   }    @override   _LinearPercentIndicatorState createState() => _LinearPercentIndicatorState(); }
/// ignore_for_file: unawaited_futures, public_member_api_docs#6149#import 'package:flutter/material.dart';
/// A file-based queue that persists on local storage for flutter mobile apps. /// /// Typical use-case scenario is for small to medium sized in-device buffers /// storing persistent yet temporary mission-critical data, until it can be /// efficiently and safely consumed / delivered permanently - such as for /// custom analytics and specialized logging applications. /// /// The current implementation is minimalist by design and only supports a /// very minimal subset of methods. All methods calls are buffered and /// executed sequentially on an isolated event loop per queue.#6149#library flutter_persistent_queue; /// A [PersistentQueue] stores data via [push] and clears it via [flush] calls.#6149#class PersistentQueue {   /// Constructs a new [PersistentQueue] or returns a previously cached one.   ///   /// [filename] gets instantiated under `ApplicationDocumentsDirectory` to   /// store/load the persistent queue.   ///   /// An optional [onFlush] handler can be supplied at construction   /// time, to be called implicitly before each [flush()] operation emptying   /// the queue. When [onFlush] is provided the queue will be emptied as long   /// as the handler does not return `false`.   ///   /// The [flushAt] and [flushTimeout] parameters specify trigger conditions   /// for firing automatic implicit [flush()] operations.   ///   /// [flushAt] establishes a desired target ceiling for locally store items,   /// with a default of `100`. It's also possible to set a [flushTimeout]   /// for a time-based [flush()] trigger, with a default [Duration] of 5   /// minutes. Both parameters can only be bypassed by setting very large   /// values, by design.   ///   /// Setting [maxLength] causes the queue to throw exceptions at [push] time   /// when the queue internally holds more elements than this hard maximum. By   /// default it's calculated as 5 times the size of [flushAt].   factory PersistentQueue(String filename,       {int flushAt = 100,       Duration flushTimeout = const Duration(minutes: 5),       int maxLength,       String nickname,       FutureOr Function(List) onFlush}) {     _configs[filename] = _Config(         flushAt: flushAt,         flushTimeout: flushTimeout,         maxLength: maxLength ?? flushAt * 5,         onFlush: onFlush);      if (_queues.containsKey(filename)) {       return _queues[filename];     }      return _queues[filename] =         PersistentQueue._internal(filename, nickname ?? filename);   }    PersistentQueue._internal(this.filename, this.nickname)       : _buffer = _Buffer() {     _ready = _defer(_reload);   }    /// Permanent storage extensionless destination filename.   final String filename;    /// Optional queue name/alias for debug purposes, defaults to [filename].   final String nickname;    static final _configs = <String, _Config>{};   static final _queues = <String, PersistentQueue>{};    final _Buffer _buffer;    DateTime _deadline;   Exception _errorState;   int _len = 0;   Future<void> _ready;    /// Actual queue length after buffered operations go through.   Future<int> get length => _defer(() => _len);    /// Flag indicating queue readiness after initial reload event.   Future<void> get ready => _ready;    /// Clear the list and return queued items.   Future<List> clear() => _flushWrap(true);    /// Dispose all queue resources.   Future<void> destroy() => _buffer.defer(_destroy);    /// Schedule a flush instruction to happen after current task buffer clears.   ///   /// An optional callback [onFlush] may be provided and the queue only gets   /// emptied if [onFlush] does not return `false`. It holds priority over the   /// also optional onFlush defined at construction time.   Future<void> flush([FutureOr Function(List) onFlush]) =>       _defer(() => _flush(onFlush));    /// Push an [item] to the end of the [PersistentQueue] after buffer clears.   ///   /// p.s. [item] must be json encodable, as `json.encode()` is called over it   Future<void> push(dynamic item) => _defer(() => _push(item));    /// Preview a [List] of currently buffered items, without any dequeuing.   Future<List> toList() => _flushWrap(false);    _Config get _config => _configs[filename];   bool get _isExpired => _deadline != null && _nowUtc.isAfter(_deadline);   DateTime get _nowUtc => DateTime.now().toUtc();    Future<T> _defer<T>(FutureOr<T> Function() action) {     void checkErrorState() {       if (_errorState != null) {         throw Exception(_errorState);       }     }      checkErrorState();      return _buffer         .defer<T>(() => Future.sync(checkErrorState).then((_) => action()));   }    Future<void> _destroy() {     _configs.remove(filename);     _queues.remove(filename);      _errorState ??= Exception('Queue Destroyed');      return _buffer.destroy();   }    Future<void> _file(Future<void> Function(LocalStorage) inputFunc) async {     final storage = LocalStorage(filename);      await storage.ready;     await inputFunc(storage);   }    Future<void> _flush([FutureOr Function(List) onFlushParam]) async {     final onFlush = onFlushParam ?? _config.onFlush ?? (_) => true;      if (((await onFlush(await _toList())) ?? true) != false) {       await _reset();     }   }    Future<List> _flushWrap(bool shouldClear) {     List list;      return flush((_list) {       list = _list;        return shouldClear;     }).then((_) => list);   }    Future<void> _push(dynamic item) async {     if (_len > _config.maxLength) {       throw Exception('QueueOverflow');     }      await _write(item);      if ((_len >= _config.flushAt) || _isExpired) {       await _flush();     }   }    Future<void> _reload() async {     try {       _errorState = null;       _len = 0;        await _file((storage) async {         while (await storage.getItem('$_len') != null) {           ++_len;         }       });     } catch (e) {       _errorState = Exception(e.toString());     }   }    Future<void> _reset() async {     await _file((storage) async {       await storage.clear();        _len = 0;     });   }    void _resetDeadline() => _deadline = _nowUtc.add(_config.flushTimeout);    Future<List> _toList() async {     if ((_len ?? 0) < 1) {       return [];     }      final li = List(_len);      await _file((storage) async {       for (int k = 0; k < _len; ++k) {         li[k] = await storage.getItem('$k');       }     });      return li;   }    Future<void> _write(dynamic value) async {     await _file((storage) async {       await storage.setItem('$_len', value);        if (++_len == 1) {         _resetDeadline();       }     });   } }
/// This file is automatically generated. DO NOT EDIT, all your changes would be lost.#6149#class S implements WidgetsLocalizations {   const S();    static S? current;    static const GeneratedLocalizationsDelegate delegate =     GeneratedLocalizationsDelegate();    static S? of(BuildContext context) => Localizations.of<S>(context, S);    @override   TextDirection get textDirection => TextDirection.ltr;  }
/// The over-scroll distance that moves the indicator to its maximum displacement, as a percentage of the scrollable's container extent.#6149#const double _kDragContainerExtentPercentage = 0.25; // How much the scroll's drag gesture can overshoot the RefreshIndicator's displacement; max displacement = _kDragSizeFactorLimit * displacement.#6149#const double _kDragSizeFactorLimit = 1.5; // When the scroll ends, the duration of the refresh indicator's animation to the RefreshIndicator's displacement.#6149#const Duration _kIndicatorSnapDuration = const Duration(milliseconds: 150); // The duration of the ScaleTransition that starts when the refresh action has completed.#6149#const Duration _kIndicatorScaleDuration = const Duration(milliseconds: 200); /// The signature for a function that's called when the user has dragged a [ReactiveRefreshIndicator] far enough to demonstrate that they want to /// instigate a refresh.#6149#typedef void RefreshCallback(); // The state machine moves through these modes only when the scrollable identified by scrollableKey has been scrolled to its min or max limit.#6149#enum _RefreshIndicatorMode {   drag, // Pointer is down.   armed, // Dragged far enough that an up event will run the onRefresh callback.   snap, // Animating to the indicator's final "displacement".   refresh, // Running the refresh callback.   done, // Animating the indicator's fade-out after refreshing.   canceled, // Animating the indicator's fade-out after not arming. } /// This is a customization of the [RefreshIndicator] widget that is reactive in design. This makes it much easier to integrate into code /// that has multiple avenues of refresh instigation. That is, refreshing in response to the user pulling down a [ListView], but also in /// response to some other stimuli, like swiping a header left or right. /// /// Instead of [onRefresh] being asynchronous as it is in [RefreshIndicator], it is synchronous. Consequently, instead of determining the /// visibility of the refresh indicator on your behalf, you must tell the control yourself via [isRefreshing]. The [onRefresh] callback is /// only executed if the user instigates a refresh via a pull-to-refresh gesture.#6149#class ReactiveRefreshIndicator extends StatefulWidget {   const ReactiveRefreshIndicator({     Key key,     @required this.child,     this.displacement: 40.0,     @required this.isRefreshing,     @required this.onRefresh,     this.color,     this.backgroundColor,     this.notificationPredicate: defaultScrollNotificationPredicate,   })  : assert(child != null),         assert(onRefresh != null),         assert(notificationPredicate != null),         assert(isRefreshing != null),         super(key: key);    final Widget child;    final double displacement;    final bool isRefreshing;    final RefreshCallback onRefresh;    final Color color;    final Color backgroundColor;    final ScrollNotificationPredicate notificationPredicate;    @override   ReactiveRefreshIndicatorState createState() =>       new ReactiveRefreshIndicatorState(); }
/// /// The example app has the ability to initiate a call from within the app; otherwise, it lists all /// calls with their state ///#6149#class MyApp extends StatefulWidget {   @override   _MyAppState createState() => _MyAppState(); }
/// Phone events created by this plugin#6149#final _localEvents = StreamController<PhoneCallEvent>.broadcast(); /// The event channel to receive native phone events#6149#final EventChannel _phoneStateCallEventChannel = /// Native event stream, lazily created.  See [nativeEvents]#6149#Stream<RawPhoneEvent> _nativeEvents; /// A stream of [RawPhoneEvent] instances.  The stream only contains null values if there was an error#6149#Stream<RawPhoneEvent> get _initializedNativeEvents {   _nativeEvents ??=       _phoneStateCallEventChannel.receiveBroadcastStream().map((dyn) {     try {       if (dyn == null) return null;       if (dyn is! Map) {         _log.warning("Unexpected result type for phone event.  "             "Expected Map<String, dynamic> but got ${dyn?.runtimeType ?? 'null'} ");       }       final Map<String, dynamic> event = (dyn as Map).cast();       final eventType = _parseEventType(event["type"] as String);       return RawPhoneEvent(           event["id"] as String, event["phoneNumber"] as String, eventType);     } catch (e, stack) {       _log.severe("Error handling native event $e", e, stack);       return null;     }   });   return _nativeEvents; } /// Removes all non-numeric characters#6149#String sanitizePhoneNumber(String input) {   String out = "";    for (var i = 0; i < input.length; ++i) {     var char = input[i];     if (_isNumeric((char))) {       out += char;     }   }   return out; }
/// Logging stream consumer#6149#typedef Logging = void Function(LogRecord record); /// Keeps the old logging subscription, so we can cancel at reconfigure#6149#StreamSubscription<LogRecord> _subscription; /// Configures a single logger.  By default will#6149#configureLogging({Logger logger, Level level, Logging onLog}) async {
/// Represents phone events that surface from the device.  These events can be subscribed to by /// using [FlutterPhoneState.rawEventStream] /// /// We recommend using [PhoneCallEvent]#6149#class RawPhoneEvent {   /// Underlying call ID assigned by the device.   /// android: always null   /// ios: a uuid   /// others: ??   final String id;    /// If available, the phone number being dialed.   final String phoneNumber;    /// The type of call event.   final RawEventType type;    RawPhoneEvent(this.id, this.phoneNumber, this.type);    /// Whether this event represents a new call   bool get isNewCall =>       type == RawEventType.inbound || type == RawEventType.outbound;    @override   String toString() {     return 'RawPhoneEvent{type: ${value(type)}, id: ${truncate(id, 12) ?? '-'}, phoneNumber: ${phoneNumber ?? '-'}}';   }    @override   bool operator ==(Object other) =>       identical(this, other) ||       other is RawPhoneEvent &&           runtimeType == other.runtimeType &&           id == other.id &&           phoneNumber == other.phoneNumber &&           type == other.type;    @override   int get hashCode => id.hashCode ^ phoneNumber.hashCode ^ type.hashCode; } /// An event surfaced from a phone call#6149#class PhoneCallEvent {   /// The call this event was attached to.   /// @non_null   final PhoneCall call;    /// What status this event represents.   /// @non_null   final PhoneCallStatus status;    /// Timestamp for this event   /// @non_null   final DateTime timestamp;    PhoneCallEvent(this.call, this.status, [DateTime eventDate])       : timestamp = eventDate ?? DateTime.now();    @override   String toString() {     return 'PhoneCallEvent{status: ${value(status)}, '         'id: ${truncate(call?.id, 12)} '         'callId: ${truncate(call?.callId, 12) ?? '-'}, '         'phoneNumber: ${call?.phoneNumber ?? '-'}}';   } } /// A representation of a phone call lifecycle.  It's impossible to be precise, but we make a /// best-ditch effort to link calls up#6149#class PhoneCall {   /// An id assigned by this plugin   /// @non_null   final String id;    /// An id assigned to the call by the underlying os   /// @nullable   String callId;    /// The phone number being dialed, or the inbound number   /// @nullabe   String phoneNumber;    /// The current status of the call   /// @non_null   PhoneCallStatus status;    /// Whether the call is inbound or outbound   /// @non_null   final PhoneCallPlacement placement;    /// When the call was started   final DateTime startTime;    /// A list of events associated with this call   final List<PhoneCallEvent> events;    /// Whether or not this call is complete.  see [isComplete]   bool _isComplete = false;    /// Used internally to track the call events, can be subscribed to, or awaited on.   StreamController<PhoneCallEvent> _eventStream;    /// The final call duration.  See [duration]   Duration _duration;    PhoneCall.start(this.phoneNumber, this.placement, [String id])       : status = null,         id = id ?? Uuid().v4(),         events = <PhoneCallEvent>[],         startTime = DateTime.now();    bool get isOutbound => placement == PhoneCallPlacement.outbound;    bool get isInbound => placement == PhoneCallPlacement.inbound;    /// Whether this call is complete   bool get isComplete => _isComplete;    /// Marks this call as complete, and returns the final event as a [FutureOr].  If the   /// event stream has subscribers, it will first close, and then return   Future<PhoneCallEvent> complete(PhoneCallStatus status) async {     if (_isComplete) {       throw "Illegal state: This call is already marked complete";     }     this._duration = DateTime.now().difference(startTime);     final event = recordStatus(status);     _isComplete = true;     if (_eventStream?.isClosed == false) {       await _eventStream.close();       return event;     } else {       return event;     }   }    /// The duration of this call.  This duration will represent the elasped time, until the call   /// completes.   Duration get duration {     return _duration ?? sinceNow(startTime);   }    /// Subscribes to all events for this call   Stream<PhoneCallEvent> get eventStream {     return _isComplete ? Stream.empty() : _getOrCreateEventController().stream;   }    /// Waits for the call to be complete.   FutureOr<PhoneCall> get done {     if (_isComplete) return this;     return _getOrCreateEventController().done.then((_) {       _log.info("Finished call.  Status $status");       return this;     });   }    /// Sometimes, the call events get mixed up or lost, and we end up with an orphaned call.  A call is orphaned if:   /// - It's in a dialing state for more than 30 seconds   /// - It's in an active state for more than 8 hours   bool get isExpired {     if (status == PhoneCallStatus.dialing && sinceNow(startTime).inSeconds > 30)       return true;     if (status == PhoneCallStatus.connected && sinceNow(startTime).inHours > 8)       return true;     return false;   }    /// Whether or not this call is expired.  See [isExpired]   bool get isNotExpired => !isExpired;    /// Whether this call can be linked to the provided event.  This check is fairly loose, it makes sure that   /// the values aren't for two disparate ids, phone numbers, and that the status is a subsequent status   bool canBeLinked(RawPhoneEvent event) {     if (event.phoneNumber != null &&         this.phoneNumber != null &&         event.phoneNumber != this.phoneNumber) return false;     if (this.callId != null && this.callId != event.id) return false;     if (isNotBefore(status, event.type)) return false;      return true;   }    @override   bool operator ==(Object other) =>       identical(this, other) ||       other is PhoneCall && runtimeType == other.runtimeType && id == other.id;    @override   int get hashCode => id.hashCode;    /// Logs a phone call status, and fires the appropriate events   PhoneCallEvent recordStatus(PhoneCallStatus status) {     this.status = status;     final event = PhoneCallEvent(this, status);     this.events.add(event);     if (_eventStream?.isClosed == true) {       throw "Illegal state for call ${truncate(id, 12)}:  Received status event after closing stream";     }     _eventStream?.add(event);     return event;   }    StreamController<PhoneCallEvent> _getOrCreateEventController() =>       _eventStream ??= StreamController<PhoneCallEvent>.broadcast(); }
/// When multiple calls are repeated, only the first time is valid. /// /// Like rxdart `throttle` method#6149#class Throttle {   Duration duration;    VoidCallback onCall;    bool _isRunning = false;    Timer _timer;    Throttle({     @required this.onCall,     this.duration = const Duration(seconds: 2),   });    void call(call) {     if (!_isRunning) {       _startTimer();       onCall?.call();     }   }    void _startTimer() {     if (_timer != null) {       _stopTimer();     }     _isRunning = true;     _timer = Timer(duration, () {       _isRunning = false;       _timer = null;     });   }    void _stopTimer() {     _timer?.cancel();     _isRunning = false;     _timer = null;   }    void dispose() {     this.onCall = null;     _stopTimer();   } }
/// A material design checkbox. /// /// The checkbox itself does not maintain any state. Instead, when the state of /// the checkbox changes, the widget calls the [onChanged] callback. Most /// widgets that use a checkbox will listen for the [onChanged] callback and /// rebuild the checkbox with a new [value] to update the visual appearance of /// the checkbox. /// /// The checkbox can optionally display three values - true, false, and null - /// if [tristate] is true. When [value] is null a dash is displayed. By default /// [tristate] is false and the checkbox's [value] must be true or false. /// /// Requires one of its ancestors to be a [Material] widget. /// /// See also: /// ///  * [CheckboxListTile], which combines this widget with a [ListTile] so that ///    you can give the checkbox a label. ///  * [Switch], a widget with semantics similar to [Checkbox]. ///  * [Radio], for selecting among a set of explicit values. ///  * [Slider], for selecting a value in a range. ///  * <https://material.google.com/components/selection-controls.html#selection-controls-checkbox> ///  * <https://material.google.com/components/lists-controls.html#lists-controls-types-of-list-controls>#6149#class Checkbox extends StatefulWidget {   /// Creates a material design checkbox.   ///   /// The checkbox itself does not maintain any state. Instead, when the state of   /// the checkbox changes, the widget calls the [onChanged] callback. Most   /// widgets that use a checkbox will listen for the [onChanged] callback and   /// rebuild the checkbox with a new [value] to update the visual appearance of   /// the checkbox.   ///   /// The following arguments are required:   ///   /// * [value], which determines whether the checkbox is checked. The [value]   ///   can only be null if [tristate] is true.   /// * [onChanged], which is called when the value of the checkbox should   ///   change. It can be set to null to disable the checkbox.   ///   /// The value of [tristate] must not be null.   const Checkbox({     Key key,     @required this.value,     this.tristate = false,     @required this.onChanged,     this.activeColor,     this.checkColor,     this.materialTapTargetSize,   })  : assert(tristate != null),         assert(tristate || value != null),         super(key: key);    /// Whether this checkbox is checked.   ///   /// This property must not be null.   final bool value;    /// Called when the value of the checkbox should change.   ///   /// The checkbox passes the new value to the callback but does not actually   /// change state until the parent widget rebuilds the checkbox with the new   /// value.   ///   /// If this callback is null, the checkbox will be displayed as disabled   /// and will not respond to input gestures.   ///   /// When the checkbox is tapped, if [tristate] is false (the default) then   /// the [onChanged] callback will be applied to `!value`. If [tristate] is   /// true this callback cycle from false to true to null.   ///   /// The callback provided to [onChanged] should update the state of the parent   /// [StatefulWidget] using the [State.setState] method, so that the parent   /// gets rebuilt; for example:   ///   /// ```dart   /// Checkbox(   ///   value: _throwShotAway,   ///   onChanged: (bool newValue) {   ///     setState(() {   ///       _throwShotAway = newValue;   ///     });   ///   },   /// )   /// ```   final ValueChanged<bool> onChanged;    /// The color to use when this checkbox is checked.   ///   /// Defaults to [ThemeData.toggleableActiveColor].   final Color activeColor;    final Color checkColor;    /// If true the checkbox's [value] can be true, false, or null.   ///   /// Checkbox displays a dash when its value is null.   ///   /// When a tri-state checkbox is tapped its [onChanged] callback will be   /// applied to true if the current value is null or false, false otherwise.   /// Typically tri-state checkboxes are disabled (the onChanged callback is   /// null) so they don't respond to taps.   ///   /// If tristate is false (the default), [value] must not be null.   final bool tristate;    /// Configures the minimum size of the tap target.   ///   /// Defaults to [ThemeData.materialTapTargetSize].   ///   /// See also:   ///   ///   * [MaterialTapTargetSize], for a description of how this affects tap targets.   final MaterialTapTargetSize materialTapTargetSize;    /// The width of a checkbox widget.   static const double width = 18.0;    @override   _CheckboxState createState() => _CheckboxState(); }
/// A [ListTile] with a [Checkbox]. In other words, a checkbox with a label. /// /// The entire list tile is interactive: tapping anywhere in the tile toggles /// the checkbox. /// /// The [value], [onChanged], and [activeColor] properties of this widget are /// identical to the similarly-named properties on the [Checkbox] widget. /// /// The [title], [subtitle], [isThreeLine], and [dense] properties are like /// those of the same name on [ListTile]. /// /// The [selected] property on this widget is similar to the [ListTile.selected] /// property, but the color used is that described by [activeColor], if any, /// defaulting to the accent color of the current [Theme]. No effort is made to /// coordinate the [selected] state and the [value] state; to have the list tile /// appear selected when the checkbox is checked, pass the same value to both. /// /// The checkbox is shown on the right by default in left-to-right languages /// (i.e. the trailing edge). This can be changed using [controlAffinity]. The /// [secondary] widget is placed on the opposite side. This maps to the /// [ListTile.leading] and [ListTile.trailing] properties of [ListTile]. /// /// To show the [CheckboxListTile] as disabled, pass null as the [onChanged] /// callback. /// /// ## Sample code /// /// This widget shows a checkbox that, when checked, slows down all animations /// (including the animation of the checkbox itself getting checked!). /// /// ```dart /// CheckboxListTile( ///   title: const Text('Animate Slowly'), ///   value: timeDilation != 1.0, ///   onChanged: (bool value) { ///     setState(() { timeDilation = value ? 20.0 : 1.0; }); ///   }, ///   secondary: const Icon(Icons.hourglass_empty), /// ) /// ``` /// /// This sample requires that you also import 'package:flutter/scheduler.dart', /// so that you can reference [timeDilation]. /// /// See also: /// ///  * [ListTileTheme], which can be used to affect the style of list tiles, ///    including checkbox list tiles. ///  * [RadioListTile], a similar widget for radio buttons. ///  * [SwitchListTile], a similar widget for switches. ///  * [ListTile] and [Checkbox], the widgets from which this widget is made.#6149#class CheckboxListTile extends StatelessWidget {   /// Creates a combination of a list tile and a checkbox.   ///   /// The checkbox tile itself does not maintain any state. Instead, when the   /// state of the checkbox changes, the widget calls the [onChanged] callback.   /// Most widgets that use a checkbox will listen for the [onChanged] callback   /// and rebuild the checkbox tile with a new [value] to update the visual   /// appearance of the checkbox.   ///   /// The following arguments are required:   ///   /// * [value], which determines whether the checkbox is checked, and must not   ///   be null.   ///   /// * [onChanged], which is called when the value of the checkbox should   ///   change. It can be set to null to disable the checkbox.   const CheckboxListTile({     Key key,     @required this.value,     @required this.onChanged,     this.activeColor,     this.checkColor,     this.title,     this.subtitle,     this.isThreeLine = false,     this.dense,     this.secondary,     this.selected = false,     this.controlAffinity = ListTileControlAffinity.platform,   })  : assert(value != null),         assert(isThreeLine != null),         assert(!isThreeLine || subtitle != null),         assert(selected != null),         assert(controlAffinity != null),         super(key: key);    /// Whether this checkbox is checked.   ///   /// This property must not be null.   final bool value;    /// Called when the value of the checkbox should change.   ///   /// The checkbox passes the new value to the callback but does not actually   /// change state until the parent widget rebuilds the checkbox tile with the   /// new value.   ///   /// If null, the checkbox will be displayed as disabled.   ///   /// The callback provided to [onChanged] should update the state of the parent   /// [StatefulWidget] using the [State.setState] method, so that the parent   /// gets rebuilt; for example:   ///   /// ```dart   /// CheckboxListTile(   ///   value: _throwShotAway,   ///   onChanged: (bool newValue) {   ///     setState(() {   ///       _throwShotAway = newValue;   ///     });   ///   },   ///   title: Text('Throw away your shot'),   /// )   /// ```   final ValueChanged<bool> onChanged;    /// The color to use when this checkbox is checked.   ///   /// Defaults to accent color of the current [Theme].   final Color activeColor;    final Color checkColor;    /// The primary content of the list tile.   ///   /// Typically a [Text] widget.   final Widget title;    /// Additional content displayed below the title.   ///   /// Typically a [Text] widget.   final Widget subtitle;    /// A widget to display on the opposite side of the tile from the checkbox.   ///   /// Typically an [Icon] widget.   final Widget secondary;    /// Whether this list tile is intended to display three lines of text.   ///   /// If false, the list tile is treated as having one line if the subtitle is   /// null and treated as having two lines if the subtitle is non-null.   final bool isThreeLine;    /// Whether this list tile is part of a vertically dense list.   ///   /// If this property is null then its value is based on [ListTileTheme.dense].   final bool dense;    /// Whether to render icons and text in the [activeColor].   ///   /// No effort is made to automatically coordinate the [selected] state and the   /// [value] state. To have the list tile appear selected when the checkbox is   /// checked, pass the same value to both.   ///   /// Normally, this property is left to its default value, false.   final bool selected;    /// Where to place the control relative to the text.   final ListTileControlAffinity controlAffinity;    @override   Widget build(BuildContext context) {     final Widget control = Checkbox(       value: value,       onChanged: onChanged,       checkColor: checkColor,       activeColor: activeColor,       materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,     );     Widget leading, trailing;     switch (controlAffinity) {       case ListTileControlAffinity.leading:         leading = control;         trailing = secondary;         break;       case ListTileControlAffinity.trailing:       case ListTileControlAffinity.platform:         leading = secondary;         trailing = control;         break;     }     return MergeSemantics(       child: ListTileTheme.merge(         selectedColor: activeColor ?? Theme.of(context).accentColor,         child: ListTile(           leading: leading,           title: title,           subtitle: subtitle,           trailing: trailing,           isThreeLine: isThreeLine,           dense: dense,           enabled: onChanged != null,           onTap: onChanged != null               ? () {                   onChanged(!value);                 }               : null,           selected: selected,         ),       ),     );   } }
/// /// [Author] Alex (https://github.com/AlexV525) /// [Date] 2021/12/27 14:57 ///#6149#import 'package:flutter/material.dart';
/// The main library that contains all functions integrating with photo library. /// /// To use, import `package:photo_manager/photo_manager.dart`.#6149#library photo_manager;
/// A series of filter options for [AssetType] when querying assets.#6149#@immutable /// Constraints of asset pixel width and height.#6149#@immutable /// Constraints of duration. /// /// The Image type ignores this constraints.#6149#@immutable
/// The group class to obtain [FilterOption]s.#6149#class FilterOptionGroup {   /// Construct a default options group.   FilterOptionGroup({     FilterOption imageOption = const FilterOption(),     FilterOption videoOption = const FilterOption(),     FilterOption audioOption = const FilterOption(),     this.containsPathModified = false,     this.containsLivePhotos = true,     this.onlyLivePhotos = false,     DateTimeCond? createTimeCond,     DateTimeCond? updateTimeCond,     List<OrderOption> orders = const <OrderOption>[],   }) {     _map[AssetType.image] = imageOption;     _map[AssetType.video] = videoOption;     _map[AssetType.audio] = audioOption;     this.createTimeCond = createTimeCond ?? this.createTimeCond;     this.updateTimeCond = updateTimeCond ?? this.updateTimeCond;     this.orders.addAll(orders);   }    /// Construct an empty options group.   FilterOptionGroup.empty();    final Map<AssetType, FilterOption> _map = <AssetType, FilterOption>{};    /// Get the [FilterOption] according the specific [AssetType].   FilterOption getOption(AssetType type) => _map[type]!;    /// Set the [FilterOption] according the specific [AssetType].   void setOption(AssetType type, FilterOption option) {     _map[type] = option;   }    /// Whether the [AssetPathEntity]s will return with modified time.   ///   /// This option is performance-consuming. Use with cautious.   ///   /// See also:   ///  * [AssetPathEntity.lastModified].   bool containsPathModified = false;    /// Whether to obtain live photos.   ///   /// This option only takes effects on iOS.   bool containsLivePhotos = true;    /// Whether to obtain only live photos.   ///   /// This option only takes effects on iOS and when the request type is image.   bool onlyLivePhotos = false;    DateTimeCond createTimeCond = DateTimeCond.def();   DateTimeCond updateTimeCond = DateTimeCond.def().copyWith(ignore: true);    final List<OrderOption> orders = <OrderOption>[];    void addOrderOption(OrderOption option) {     orders.add(option);   }    void merge(FilterOptionGroup other) {     for (final AssetType type in _map.keys) {       _map[type] = _map[type]!.merge(other.getOption(type));     }     containsPathModified = other.containsPathModified;     containsLivePhotos = other.containsLivePhotos;     onlyLivePhotos = other.onlyLivePhotos;     createTimeCond = other.createTimeCond;     updateTimeCond = other.updateTimeCond;     orders       ..clear()       ..addAll(other.orders);   }    Map<String, dynamic> toMap() {     return <String, dynamic>{       if (_map.containsKey(AssetType.image))         'image': getOption(AssetType.image).toMap(),       if (_map.containsKey(AssetType.video))         'video': getOption(AssetType.video).toMap(),       if (_map.containsKey(AssetType.audio))         'audio': getOption(AssetType.audio).toMap(),       'containsPathModified': containsPathModified,       'containsLivePhotos': containsLivePhotos,       'onlyLivePhotos': onlyLivePhotos,       'createDate': createTimeCond.toMap(),       'updateDate': updateTimeCond.toMap(),       'orders': orders.map((OrderOption e) => e.toMap()).toList(),     };   }    FilterOptionGroup copyWith({     FilterOption? imageOption,     FilterOption? videoOption,     FilterOption? audioOption,     bool? containsPathModified,     bool? containsLivePhotos,     bool? onlyLivePhotos,     DateTimeCond? createTimeCond,     DateTimeCond? updateTimeCond,     List<OrderOption>? orders,   }) {     imageOption ??= _map[AssetType.image];     videoOption ??= _map[AssetType.video];     audioOption ??= _map[AssetType.audio];     containsPathModified ??= this.containsPathModified;     containsLivePhotos ??= this.containsLivePhotos;     onlyLivePhotos ??= this.onlyLivePhotos;     createTimeCond ??= this.createTimeCond;     updateTimeCond ??= this.updateTimeCond;     orders ??= this.orders;      final FilterOptionGroup result = FilterOptionGroup()       ..setOption(AssetType.image, imageOption!)       ..setOption(AssetType.video, videoOption!)       ..setOption(AssetType.audio, audioOption!)       ..containsPathModified = containsPathModified       ..containsLivePhotos = containsLivePhotos       ..onlyLivePhotos = onlyLivePhotos       ..createTimeCond = createTimeCond       ..updateTimeCond = updateTimeCond       ..orders.addAll(orders);      return result;   }    @override   String toString() {     return const JsonEncoder.withIndent('  ').convert(toMap());   } }
/// {@template photo_manager.AssetType} /// The type of the asset. /// /// Most of assets are [AssetType.image] and [AssetType.video], /// some assets might be [AssetType.audio] on Android. /// The [AssetType.other] type won't show in general. /// {@endtemplate} /// /// **IMPORTANT FOR MAINTAINERS:** **DO NOT** change orders of values.#6149#enum AssetType {   other,   image,   video,   audio, } /// {@template photo_manager.ThumbnailFormat} /// Which format the thumbnail should be, generally support JPG and PNG. /// {@endtemplate}#6149#enum ThumbnailFormat { jpeg, png } /// Enumeration for `PHImageRequestOptionsDeliveryMode` on iOS/macOS. /// /// See also: ///  * [Apple documentation](https://developer.apple.com/documentation/photokit/phimagerequestoptionsdeliverymode)#6149#enum DeliveryMode { opportunistic, highQualityFormat, fastFormat } /// Specifies how to resize the requested image on iOS/macOS. /// /// See also: ///  * [Apple documentation](https://developer.apple.com/documentation/photokit/phimagerequestoptions/1616988-resizemode)#6149#enum ResizeMode { none, fast, exact } /// Fitting an image’s aspect ratio to a requested size on iOS/macOS. /// /// See also: ///  * [Apple documentation](https://developer.apple.com/documentation/photokit/phimagecontentmode)#6149#enum ResizeContentMode { fit, fill, def } /// {@template photo_manager.PMRequestState} /// Indicate the current state when an asset is loading with [PMProgressHandler]. /// {@endtemplate}#6149#enum PMRequestState { prepare, loading, success, failed } /// Information about app’s authorization to access the user’s photo library. ///  * Android: Only [authorized] and [denied] are valid. ///  * iOS/macOS: All valid. /// /// See also: ///  * [Apple documentation](https://developer.apple.com/documentation/photokit/phauthorizationstatus)#6149#enum PermissionState {   /// The user has not set the app’s authorization status.   notDetermined,    /// The app isn’t authorized to access the photo library, and the user can’t grant such permission.   restricted,    /// The user explicitly denied this app access to the photo library.   denied,    /// The user explicitly granted this app access to the photo library.   authorized,    /// The user authorized this app for limited photo library access.   ///   /// This state only supports iOS 14 and above.   limited, } /// The app’s level of access to the user’s photo library. /// /// See also: ///  * [Apple documentation](https://developer.apple.com/documentation/photokit/phaccesslevel)#6149#enum IosAccessLevel { addOnly, readWrite } /// Common file types for images.#6149#enum ImageFileType { jpg, png, gif, tiff, heic, other } /// Some special image types.#6149#enum SpecialImageType { gif, heic }
/// The [ImageProvider] that handles [AssetEntity]. /// /// Only support [AssetType.image] and [AssetType.video], /// others will throw errors during the resolving. /// /// If [isOriginal] is true: ///   * Fetch [AssetEntity.thumbnailData] for [AssetType.video]. ///   * Fetch [AssetEntity.file] and convert to bytes for HEIF(HEIC) images. ///   * Fetch [AssetEntity.originBytes] for images. /// Else, fetch [AssetEntity.thumbnailDataWithOption] with the given /// [thumbnailSize] and the [thumbnailFormat].#6149#@immutable /// A widget that displays an [AssetEntity] image. /// /// The widget uses [AssetEntityImageProvider] internally to resolve assets.#6149#class AssetEntityImage extends Image {   AssetEntityImage(     this.entity, {     this.isOriginal = true,     this.thumbnailSize = PMConstants.vDefaultGridThumbnailSize,     this.thumbnailFormat = ThumbnailFormat.jpeg,     Key? key,     ImageFrameBuilder? frameBuilder,     ImageLoadingBuilder? loadingBuilder,     ImageErrorWidgetBuilder? errorBuilder,     String? semanticLabel,     bool excludeFromSemantics = false,     double? width,     double? height,     Color? color,     Animation<double>? opacity,     BlendMode? colorBlendMode,     BoxFit? fit,     AlignmentGeometry alignment = Alignment.center,     ImageRepeat repeat = ImageRepeat.noRepeat,     Rect? centerSlice,     bool matchTextDirection = false,     bool gaplessPlayback = false,     bool isAntiAlias = false,     FilterQuality filterQuality = FilterQuality.low,   }) : super(           key: key,           image: AssetEntityImageProvider(             entity,             isOriginal: isOriginal,             thumbnailSize: thumbnailSize,             thumbnailFormat: thumbnailFormat,           ),           frameBuilder: frameBuilder,           loadingBuilder: loadingBuilder,           errorBuilder: errorBuilder,           semanticLabel: semanticLabel,           excludeFromSemantics: excludeFromSemantics,           width: width,           height: height,           color: color,           opacity: opacity,           colorBlendMode: colorBlendMode,           fit: fit,           alignment: alignment,           repeat: repeat,           centerSlice: centerSlice,           matchTextDirection: matchTextDirection,           gaplessPlayback: gaplessPlayback,           isAntiAlias: isAntiAlias,           filterQuality: filterQuality,         );    final AssetEntity entity;   final bool isOriginal;   final ThumbnailSize? thumbnailSize;   final ThumbnailFormat thumbnailFormat;    @override   void debugFillProperties(DiagnosticPropertiesBuilder properties) {     super.debugFillProperties(properties);     properties.add(DiagnosticsProperty<AssetEntity>('entity', entity));     properties.add(DiagnosticsProperty<bool>('isOriginal', isOriginal));     properties.add(       DiagnosticsProperty<ThumbnailSize>('thumbnailSize', thumbnailSize),     );     properties.add(       DiagnosticsProperty<ThumbnailFormat>('thumbnailFormat', thumbnailFormat),     );   } }
/// The plugin class is the core class that call channel's methods.#6149#class PhotoManagerPlugin with BasePlugin, IosPlugin, AndroidPlugin {   Future<List<AssetPathEntity>> getAssetPathList({     bool hasAll = true,     bool onlyAll = false,     RequestType type = RequestType.common,     FilterOptionGroup? filterOption,   }) async {     if (onlyAll) {       assert(hasAll, 'If only is true, then the hasAll must be not null.');     }     filterOption ??= FilterOptionGroup();     // Avoid filtering live photos when searching for audios.     if (type == RequestType.audio) {       filterOption = filterOption.copyWith(         containsLivePhotos: false,         onlyLivePhotos: false,       );     }     assert(       type == RequestType.image || !filterOption.onlyLivePhotos,       'Filtering only Live Photos is only supported '       'when the request type contains image.',     );     final Map<dynamic, dynamic>? result = await _channel.invokeMethod(       PMConstants.mGetAssetPathList,       <String, dynamic>{         'type': type.value,         'hasAll': hasAll,         'onlyAll': onlyAll,         'option': filterOption.toMap(),       },     );     if (result == null) {       return <AssetPathEntity>[];     }     return ConvertUtils.convertToPathList(       result.cast<String, dynamic>(),       type: type,       optionGroup: filterOption,     );   }    Future<PermissionState> requestPermissionExtend(     PermissionRequestOption requestOption,   ) async {     final int result = await _channel.invokeMethod<int>(       PMConstants.mRequestPermissionExtend,       requestOption.toMap(),     ) as int;     return PermissionState.values[result];   }    Future<int> getAssetCountFromPath(AssetPathEntity path) async {     // Use `assetCount` for Android until we break the API     // and migrate to `InternalAssetPathEntity`.     if (Platform.isAndroid) {       // ignore: deprecated_member_use_from_same_package       return path.assetCount;     }     final int result = await _channel.invokeMethod<int>(       PMConstants.mGetAssetCountFromPath,       <String, dynamic>{         'id': path.id,         'type': path.type.value,         'option': path.filterOption.toMap(),       },     ) as int;     return result;   }    /// Use pagination to get album content.   Future<List<AssetEntity>> getAssetListPaged(     String id, {     required FilterOptionGroup optionGroup,     int page = 0,     int size = 15,     RequestType type = RequestType.common,   }) async {     final Map<dynamic, dynamic> result =         await _channel.invokeMethod<Map<dynamic, dynamic>>(       PMConstants.mGetAssetListPaged,       <String, dynamic>{         'id': id,         'type': type.value,         'page': page,         'size': size,         'option': optionGroup.toMap(),       },     ) as Map<dynamic, dynamic>;     return ConvertUtils.convertToAssetList(result.cast<String, dynamic>());   }    /// Asset in the specified range.   Future<List<AssetEntity>> getAssetListRange(     String id, {     required RequestType type,     required int start,     required int end,     required FilterOptionGroup optionGroup,   }) async {     final Map<dynamic, dynamic> map =         await _channel.invokeMethod<Map<dynamic, dynamic>>(       PMConstants.mGetAssetListRange,       <String, dynamic>{         'id': id,         'type': type.value,         'start': start,         'end': end,         'option': optionGroup.toMap(),       },     ) as Map<dynamic, dynamic>;      return ConvertUtils.convertToAssetList(map.cast<String, dynamic>());   }    void _injectParams(     Map<String, dynamic> params,     PMProgressHandler? progressHandler,   ) {     if (progressHandler != null) {       params['progressHandler'] = progressHandler.channelIndex;     }   }    /// Get thumbnail of asset id.   Future<typed_data.Uint8List?> getThumbnail({     required String id,     required ThumbnailOption option,     PMProgressHandler? progressHandler,   }) {     final Map<String, dynamic> params = <String, dynamic>{       'id': id,       'option': option.toMap(),     };     _injectParams(params, progressHandler);     return _channel.invokeMethod(PMConstants.mGetThumb, params);   }    Future<typed_data.Uint8List?> getOriginBytes(     String id, {     PMProgressHandler? progressHandler,   }) {     final Map<String, dynamic> params = <String, dynamic>{'id': id};     _injectParams(params, progressHandler);     return _channel.invokeMethod(PMConstants.mGetOriginBytes, params);   }    Future<void> releaseCache() {     return _channel.invokeMethod(PMConstants.mReleaseMemoryCache);   }    Future<String?> getFullFile(     String id, {     required bool isOrigin,     PMProgressHandler? progressHandler,     int subtype = 0,   }) async {     final Map<String, dynamic> params = <String, dynamic>{       'id': id,       'isOrigin': isOrigin,       'subtype': subtype,     };     _injectParams(params, progressHandler);     return _channel.invokeMethod(PMConstants.mGetFullFile, params);   }    Future<void> setLog(bool isLog) {     return _channel.invokeMethod(PMConstants.mLog, isLog);   }    Future<void> openSetting() {     return _channel.invokeMethod(PMConstants.mOpenSetting);   }    Future<Map<dynamic, dynamic>?> fetchEntityProperties(String id) {     return _channel.invokeMethod(       PMConstants.mFetchEntityProperties,       <String, dynamic>{'id': id},     );   }    Future<Map<dynamic, dynamic>?> fetchPathProperties(     String id,     RequestType type,     FilterOptionGroup optionGroup,   ) {     return _channel.invokeMethod(       PMConstants.mFetchPathProperties,       <String, dynamic>{         'id': id,         'timestamp': 0,         'type': type.value,         'option': optionGroup.toMap(),       },     );   }    /// Return [true] if the invoke succeed.   Future<bool> notifyChange({required bool start}) async {     await _channel.invokeMethod(       PMConstants.mNotify,       <String, dynamic>{'notify': start},     );     return true;   }